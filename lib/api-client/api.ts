/* tslint:disable */
/* eslint-disable */
/**
 * Document Management System API
 * API for document management system
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivityLogDTO
 */
export interface ActivityLogDTO {
    /**
     * 
     * @type {number}
     * @memberof ActivityLogDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogDTO
     */
    'actionType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogDTO
     */
    'actionDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogDTO
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogDTO
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogDTO
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogDTO
     */
    'documentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogDTO
     */
    'documentTitle'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogDTO
     */
    'workCaseId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogDTO
     */
    'workCaseTitle'?: string;
}
/**
 * Login credentials
 * @export
 * @interface AuthRequest
 */
export interface AuthRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequest
     */
    'password': string;
}
/**
 * Role details
 * @export
 * @interface CustomRoleDTO
 */
export interface CustomRoleDTO {
    /**
     * 
     * @type {number}
     * @memberof CustomRoleDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomRoleDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRoleDTO
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRoleDTO
     */
    'systemRole'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomRoleDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRoleDTO
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomRoleDTO
     */
    'createdById'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomRoleDTO
     */
    'createdByName'?: string;
    /**
     * 
     * @type {Set<PermissionDTO>}
     * @memberof CustomRoleDTO
     */
    'permissions'?: Set<PermissionDTO>;
}
/**
 * 
 * @export
 * @interface DashboardDTO
 */
export interface DashboardDTO {
    /**
     * 
     * @type {number}
     * @memberof DashboardDTO
     */
    'incomingDocumentCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DashboardDTO
     */
    'outgoingDocumentCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DashboardDTO
     */
    'workCaseCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DashboardDTO
     */
    'pendingDocumentCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DashboardDTO
     */
    'overdueDocumentCount'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DashboardDTO
     */
    'documentCountsByType'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DashboardDTO
     */
    'documentCountsByMonth'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DashboardDTO
     */
    'processingTimeStatistics'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof DashboardDTO
     */
    'departmentPerformance'?: { [key: string]: object; };
    /**
     * 
     * @type {Array<UserActivityDTO>}
     * @memberof DashboardDTO
     */
    'topActiveUsers'?: Array<UserActivityDTO>;
    /**
     * 
     * @type {Array<UnifiedDocumentDTO>}
     * @memberof DashboardDTO
     */
    'recentDocuments'?: Array<UnifiedDocumentDTO>;
}
/**
 * Department details
 * @export
 * @interface DepartmentDTO
 */
export interface DepartmentDTO {
    /**
     * 
     * @type {number}
     * @memberof DepartmentDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DepartmentDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DepartmentDTO
     */
    'abbreviation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DepartmentDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof DepartmentDTO
     */
    'type'?: DepartmentDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DepartmentDTO
     */
    'externalId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DepartmentDTO
     */
    'group'?: string;
    /**
     * 
     * @type {number}
     * @memberof DepartmentDTO
     */
    'userCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DepartmentDTO
     */
    'assignedDocumentsCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof DepartmentDTO
     */
    'storageLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DepartmentDTO
     */
    'typeName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DepartmentDTO
     */
    'typeCode'?: number;
}

export const DepartmentDTOTypeEnum = {
    Administrative: 'ADMINISTRATIVE',
    Professional: 'PROFESSIONAL',
    Support: 'SUPPORT',
    Subsidiary: 'SUBSIDIARY',
    Leadership: 'LEADERSHIP'
} as const;

export type DepartmentDTOTypeEnum = typeof DepartmentDTOTypeEnum[keyof typeof DepartmentDTOTypeEnum];

/**
 * 
 * @export
 * @interface DocumentAttachmentDTO
 */
export interface DocumentAttachmentDTO {
    /**
     * 
     * @type {number}
     * @memberof DocumentAttachmentDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentAttachmentDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentAttachmentDTO
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentAttachmentDTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentAttachmentDTO
     */
    'uploadDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentAttachmentDTO
     */
    'uploadedBy'?: string;
}
/**
 * 
 * @export
 * @interface DocumentCommentDTO
 */
export interface DocumentCommentDTO {
    /**
     * 
     * @type {number}
     * @memberof DocumentCommentDTO
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentCommentDTO
     */
    'documentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentCommentDTO
     */
    'documentTitle'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentCommentDTO
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentCommentDTO
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentCommentDTO
     */
    'userAvatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentCommentDTO
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentCommentDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentCommentDTO
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface DocumentDepartmentDTO
 */
export interface DocumentDepartmentDTO {
    /**
     * 
     * @type {number}
     * @memberof DocumentDepartmentDTO
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentDepartmentDTO
     */
    'documentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentDepartmentDTO
     */
    'documentTitle'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentDepartmentDTO
     */
    'departmentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentDepartmentDTO
     */
    'departmentName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentDepartmentDTO
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentDepartmentDTO
     */
    'assignedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentDepartmentDTO
     */
    'dueDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentDepartmentDTO
     */
    'assignedById'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentDepartmentDTO
     */
    'assignedByName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentDepartmentDTO
     */
    'processingStatus'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentDepartmentDTO
     */
    'primary'?: boolean;
}
/**
 * 
 * @export
 * @interface DocumentHistoryDTO
 */
export interface DocumentHistoryDTO {
    /**
     * 
     * @type {number}
     * @memberof DocumentHistoryDTO
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DocumentHistoryDTO
     */
    'documentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'documentTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'previousStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'previousStatusDisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'newStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'newStatusDisplayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentHistoryDTO
     */
    'actorId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'actorName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentHistoryDTO
     */
    'assignedToId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentHistoryDTO
     */
    'assignedToName'?: string;
}
/**
 * Workflow details
 * @export
 * @interface DocumentWorkflowDTO
 */
export interface DocumentWorkflowDTO {
    /**
     * 
     * @type {number}
     * @memberof DocumentWorkflowDTO
     */
    'documentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentWorkflowDTO
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWorkflowDTO
     */
    'statusDisplayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentWorkflowDTO
     */
    'assignedToId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentWorkflowDTO
     */
    'assignedToName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWorkflowDTO
     */
    'comments'?: string;
}
/**
 * Document details
 * @export
 * @interface IncomingDocumentDTO
 */
export interface IncomingDocumentDTO {
    /**
     * 
     * @type {number}
     * @memberof IncomingDocumentDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'documentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'documentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'referenceNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'issuingAuthority'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'urgencyLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'securityLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'signingDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'receivedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'processingStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'displayStatus'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IncomingDocumentDTO
     */
    'closureRequest'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'sendingDepartmentName'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'emailSource'?: string;
    /**
     * 
     * @type {number}
     * @memberof IncomingDocumentDTO
     */
    'primaryProcessorId'?: number;
    /**
     * 
     * @type {UserDTO}
     * @memberof IncomingDocumentDTO
     */
    'primaryProcessor'?: UserDTO;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'changed'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'attachmentFilename'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncomingDocumentDTO
     */
    'storageLocation'?: string;
}
/**
 * Document details
 * @export
 * @interface OutgoingDocumentDTO
 */
export interface OutgoingDocumentDTO {
    /**
     * 
     * @type {number}
     * @memberof OutgoingDocumentDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'documentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'documentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'referenceNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof OutgoingDocumentDTO
     */
    'signerId'?: number;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'signerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'signingDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof OutgoingDocumentDTO
     */
    'draftingDepartment'?: number;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'relatedDocuments'?: string;
    /**
     * 
     * @type {number}
     * @memberof OutgoingDocumentDTO
     */
    'storageLocation'?: number;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'documentVolume'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'emailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'receivingDepartmentText'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'changed'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutgoingDocumentDTO
     */
    'attachmentFilename'?: string;
}
/**
 * 
 * @export
 * @interface PageDepartmentDTO
 */
export interface PageDepartmentDTO {
    /**
     * 
     * @type {number}
     * @memberof PageDepartmentDTO
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageDepartmentDTO
     */
    'totalPages'?: number;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageDepartmentDTO
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageDepartmentDTO
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageDepartmentDTO
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageDepartmentDTO
     */
    'size'?: number;
    /**
     * 
     * @type {Array<DepartmentDTO>}
     * @memberof PageDepartmentDTO
     */
    'content'?: Array<DepartmentDTO>;
    /**
     * 
     * @type {number}
     * @memberof PageDepartmentDTO
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageDepartmentDTO
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {number}
     * @memberof PageDepartmentDTO
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageDepartmentDTO
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface PageIncomingDocumentDTO
 */
export interface PageIncomingDocumentDTO {
    /**
     * 
     * @type {number}
     * @memberof PageIncomingDocumentDTO
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageIncomingDocumentDTO
     */
    'totalPages'?: number;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageIncomingDocumentDTO
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageIncomingDocumentDTO
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageIncomingDocumentDTO
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageIncomingDocumentDTO
     */
    'size'?: number;
    /**
     * 
     * @type {Array<IncomingDocumentDTO>}
     * @memberof PageIncomingDocumentDTO
     */
    'content'?: Array<IncomingDocumentDTO>;
    /**
     * 
     * @type {number}
     * @memberof PageIncomingDocumentDTO
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageIncomingDocumentDTO
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {number}
     * @memberof PageIncomingDocumentDTO
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageIncomingDocumentDTO
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface PageOutgoingDocumentDTO
 */
export interface PageOutgoingDocumentDTO {
    /**
     * 
     * @type {number}
     * @memberof PageOutgoingDocumentDTO
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageOutgoingDocumentDTO
     */
    'totalPages'?: number;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageOutgoingDocumentDTO
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageOutgoingDocumentDTO
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageOutgoingDocumentDTO
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageOutgoingDocumentDTO
     */
    'size'?: number;
    /**
     * 
     * @type {Array<OutgoingDocumentDTO>}
     * @memberof PageOutgoingDocumentDTO
     */
    'content'?: Array<OutgoingDocumentDTO>;
    /**
     * 
     * @type {number}
     * @memberof PageOutgoingDocumentDTO
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageOutgoingDocumentDTO
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {number}
     * @memberof PageOutgoingDocumentDTO
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageOutgoingDocumentDTO
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface PageUnifiedDocumentDTO
 */
export interface PageUnifiedDocumentDTO {
    /**
     * 
     * @type {number}
     * @memberof PageUnifiedDocumentDTO
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageUnifiedDocumentDTO
     */
    'totalPages'?: number;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageUnifiedDocumentDTO
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageUnifiedDocumentDTO
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageUnifiedDocumentDTO
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageUnifiedDocumentDTO
     */
    'size'?: number;
    /**
     * 
     * @type {Array<UnifiedDocumentDTO>}
     * @memberof PageUnifiedDocumentDTO
     */
    'content'?: Array<UnifiedDocumentDTO>;
    /**
     * 
     * @type {number}
     * @memberof PageUnifiedDocumentDTO
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageUnifiedDocumentDTO
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {number}
     * @memberof PageUnifiedDocumentDTO
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageUnifiedDocumentDTO
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface PageWorkCaseDTO
 */
export interface PageWorkCaseDTO {
    /**
     * 
     * @type {number}
     * @memberof PageWorkCaseDTO
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageWorkCaseDTO
     */
    'totalPages'?: number;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageWorkCaseDTO
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageWorkCaseDTO
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageWorkCaseDTO
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageWorkCaseDTO
     */
    'size'?: number;
    /**
     * 
     * @type {Array<WorkCaseDTO>}
     * @memberof PageWorkCaseDTO
     */
    'content'?: Array<WorkCaseDTO>;
    /**
     * 
     * @type {number}
     * @memberof PageWorkCaseDTO
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageWorkCaseDTO
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {number}
     * @memberof PageWorkCaseDTO
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageWorkCaseDTO
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    'sort'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'offset'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageableObject
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'paged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'unpaged'?: boolean;
}
/**
 * Permission details
 * @export
 * @interface PermissionDTO
 */
export interface PermissionDTO {
    /**
     * 
     * @type {number}
     * @memberof PermissionDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PermissionDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionDTO
     */
    'category'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionDTO
     */
    'systemPermission'?: boolean;
}
/**
 * Sender details
 * @export
 * @interface SenderDTO
 */
export interface SenderDTO {
    /**
     * 
     * @type {number}
     * @memberof SenderDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SenderDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SenderDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SenderDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof SenderDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface SortObject
 */
export interface SortObject {
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'sorted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'empty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'unsorted'?: boolean;
}
/**
 * 
 * @export
 * @interface UnifiedDocumentDTO
 */
export interface UnifiedDocumentDTO {
    /**
     * 
     * @type {number}
     * @memberof UnifiedDocumentDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'referenceNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'referenceDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'issuingAgency'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'processingDepartmentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'processingDepartment'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'receivedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'receivedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'securityLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'urgencyLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'status'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UnifiedDocumentDTO
     */
    'hasAttachment'?: boolean;
    /**
     * 
     * @type {Array<DocumentAttachmentDTO>}
     * @memberof UnifiedDocumentDTO
     */
    'attachments'?: Array<DocumentAttachmentDTO>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UnifiedDocumentDTO
     */
    'assignedUsers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'deadline'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UnifiedDocumentDTO
     */
    'requiresResponse'?: boolean;
    /**
     * 
     * @type {Array<DocumentCommentDTO>}
     * @memberof UnifiedDocumentDTO
     */
    'comments'?: Array<DocumentCommentDTO>;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'documentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnifiedDocumentDTO
     */
    'content'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UnifiedDocumentDTO
     */
    'includesEnclosure'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UnifiedDocumentDTO
     */
    'primaryHandler'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UnifiedDocumentDTO
     */
    'legalDocument'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UnifiedDocumentDTO
     */
    'confidentialReturn'?: boolean;
}
/**
 * 
 * @export
 * @interface UserActivityDTO
 */
export interface UserActivityDTO {
    /**
     * 
     * @type {number}
     * @memberof UserActivityDTO
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserActivityDTO
     */
    'userName'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserActivityDTO
     */
    'documentsProcessed'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserActivityDTO
     */
    'averageProcessingTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserActivityDTO
     */
    'currentAssignments'?: number;
}
/**
 * User registration details
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
    /**
     * 
     * @type {number}
     * @memberof UserDTO
     */
    'uid'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'pass'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'mail'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserDTO
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'userStatus'?: UserDTOUserStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'lastAccess'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'lastLogin'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof UserDTO
     */
    'roles'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof UserDTO
     */
    'userRoles'?: Set<UserDTOUserRolesEnum>;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    'statusDisplayName'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof UserDTO
     */
    'roleDisplayNames'?: Set<string>;
}

export const UserDTOUserStatusEnum = {
    Inactive: 'INACTIVE',
    Active: 'ACTIVE',
    Blocked: 'BLOCKED',
    PendingApproval: 'PENDING_APPROVAL'
} as const;

export type UserDTOUserStatusEnum = typeof UserDTOUserStatusEnum[keyof typeof UserDTOUserStatusEnum];
export const UserDTOUserRolesEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    Editor: 'EDITOR',
    DepartmentHead: 'DEPARTMENT_HEAD',
    DeputyDepartmentHead: 'DEPUTY_DEPARTMENT_HEAD',
    BureauChief: 'BUREAU_CHIEF',
    DeputyBureauChief: 'DEPUTY_BUREAU_CHIEF',
    Staff: 'STAFF',
    Secretary: 'SECRETARY',
    Clerk: 'CLERK'
} as const;

export type UserDTOUserRolesEnum = typeof UserDTOUserRolesEnum[keyof typeof UserDTOUserRolesEnum];

/**
 * Work case details
 * @export
 * @interface WorkCaseDTO
 */
export interface WorkCaseDTO {
    /**
     * 
     * @type {number}
     * @memberof WorkCaseDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'caseCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'priority'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'deadline'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkCaseDTO
     */
    'createdById'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'createdByName'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkCaseDTO
     */
    'assignedToId'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'assignedToName'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkCaseDTO
     */
    'progress'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkCaseDTO
     */
    'tags'?: string;
    /**
     * 
     * @type {Set<number>}
     * @memberof WorkCaseDTO
     */
    'documentIds'?: Set<number>;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticates a user and returns a JWT token
         * @summary User login
         * @param {AuthRequest} authRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (authRequest: AuthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRequest' is not null or undefined
            assertParamExists('login', 'authRequest', authRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account
         * @summary Register new user
         * @param {UserDTO} userDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (userDTO: UserDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userDTO' is not null or undefined
            assertParamExists('register', 'userDTO', userDTO)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticates a user and returns a JWT token
         * @summary User login
         * @param {AuthRequest} authRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(authRequest: AuthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(authRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account
         * @summary Register new user
         * @param {UserDTO} userDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(userDTO: UserDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(userDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticates a user and returns a JWT token
         * @summary User login
         * @param {AuthRequest} authRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(authRequest: AuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.login(authRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account
         * @summary Register new user
         * @param {UserDTO} userDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(userDTO: UserDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.register(userDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticates a user and returns a JWT token
     * @summary User login
     * @param {AuthRequest} authRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(authRequest: AuthRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(authRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user account
     * @summary Register new user
     * @param {UserDTO} userDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public register(userDTO: UserDTO, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(userDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns statistics for the dashboard
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns performance metrics by department
         * @summary Get department performance report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentPerformanceReport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/reports/department-performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns activity logs for a specific document
         * @summary Get document activity logs
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentActivities: async (documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentActivities', 'documentId', documentId)
            const localVarPath = `/api/dashboard/document-activities/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns document counts grouped by month within a date range
         * @summary Get document counts by month
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentCountsByMonth: async (start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getDocumentCountsByMonth', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getDocumentCountsByMonth', 'end', end)
            const localVarPath = `/api/dashboard/document-counts-by-month`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns document counts grouped by document type
         * @summary Get document counts by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentCountsByType: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/document-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a comprehensive report on document volumes
         * @summary Get document volume report
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentVolumeReport: async (start: string, end: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getDocumentVolumeReport', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getDocumentVolumeReport', 'end', end)
            const localVarPath = `/api/dashboard/reports/document-volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns statistics about document processing times
         * @summary Get document processing time statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingTimeStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/processing-times`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the most recent activity logs
         * @summary Get recent activity logs
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/recent-activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the most active users with their activity statistics
         * @summary Get top active users
         * @param {number} [limit] Number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopActiveUsers: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/top-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns activity logs for a specific user
         * @summary Get user activity logs
         * @param {number} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivities: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserActivities', 'userId', userId)
            const localVarPath = `/api/dashboard/user-activities/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns statistics for the dashboard
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboardStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns performance metrics by department
         * @summary Get department performance report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepartmentPerformanceReport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartmentPerformanceReport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDepartmentPerformanceReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns activity logs for a specific document
         * @summary Get document activity logs
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentActivities(documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityLogDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentActivities(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDocumentActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns document counts grouped by month within a date range
         * @summary Get document counts by month
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentCountsByMonth(start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentCountsByMonth(start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDocumentCountsByMonth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns document counts grouped by document type
         * @summary Get document counts by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentCountsByType(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentCountsByType(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDocumentCountsByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a comprehensive report on document volumes
         * @summary Get document volume report
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentVolumeReport(start: string, end: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentVolumeReport(start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDocumentVolumeReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns statistics about document processing times
         * @summary Get document processing time statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessingTimeStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessingTimeStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getProcessingTimeStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the most recent activity logs
         * @summary Get recent activity logs
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentActivities(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityLogDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentActivities(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getRecentActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the most active users with their activity statistics
         * @summary Get top active users
         * @param {number} [limit] Number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopActiveUsers(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserActivityDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopActiveUsers(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getTopActiveUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns activity logs for a specific user
         * @summary Get user activity logs
         * @param {number} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserActivities(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityLogDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserActivities(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getUserActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * Returns statistics for the dashboard
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardStatistics(options?: RawAxiosRequestConfig): AxiosPromise<DashboardDTO> {
            return localVarFp.getDashboardStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns performance metrics by department
         * @summary Get department performance report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentPerformanceReport(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getDepartmentPerformanceReport(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns activity logs for a specific document
         * @summary Get document activity logs
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentActivities(documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActivityLogDTO>> {
            return localVarFp.getDocumentActivities(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns document counts grouped by month within a date range
         * @summary Get document counts by month
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentCountsByMonth(start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getDocumentCountsByMonth(start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns document counts grouped by document type
         * @summary Get document counts by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentCountsByType(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getDocumentCountsByType(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a comprehensive report on document volumes
         * @summary Get document volume report
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentVolumeReport(start: string, end: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getDocumentVolumeReport(start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns statistics about document processing times
         * @summary Get document processing time statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingTimeStatistics(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getProcessingTimeStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the most recent activity logs
         * @summary Get recent activity logs
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActivityLogDTO>> {
            return localVarFp.getRecentActivities(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the most active users with their activity statistics
         * @summary Get top active users
         * @param {number} [limit] Number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopActiveUsers(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserActivityDTO>> {
            return localVarFp.getTopActiveUsers(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns activity logs for a specific user
         * @summary Get user activity logs
         * @param {number} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivities(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActivityLogDTO>> {
            return localVarFp.getUserActivities(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * Returns statistics for the dashboard
     * @summary Get dashboard statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardStatistics(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns performance metrics by department
     * @summary Get department performance report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDepartmentPerformanceReport(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDepartmentPerformanceReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns activity logs for a specific document
     * @summary Get document activity logs
     * @param {number} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDocumentActivities(documentId: number, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDocumentActivities(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns document counts grouped by month within a date range
     * @summary Get document counts by month
     * @param {string} start Start date (ISO format)
     * @param {string} end End date (ISO format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDocumentCountsByMonth(start: string, end: string, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDocumentCountsByMonth(start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns document counts grouped by document type
     * @summary Get document counts by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDocumentCountsByType(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDocumentCountsByType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a comprehensive report on document volumes
     * @summary Get document volume report
     * @param {string} start Start date (ISO format)
     * @param {string} end End date (ISO format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDocumentVolumeReport(start: string, end: string, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDocumentVolumeReport(start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns statistics about document processing times
     * @summary Get document processing time statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getProcessingTimeStatistics(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getProcessingTimeStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the most recent activity logs
     * @summary Get recent activity logs
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getRecentActivities(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getRecentActivities(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the most active users with their activity statistics
     * @summary Get top active users
     * @param {number} [limit] Number of users to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getTopActiveUsers(limit?: number, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getTopActiveUsers(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns activity logs for a specific user
     * @summary Get user activity logs
     * @param {number} userId ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getUserActivities(userId: number, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getUserActivities(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepartmentsApi - axios parameter creator
 * @export
 */
export const DepartmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new department
         * @summary Create new department
         * @param {DepartmentDTO} departmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepartment: async (departmentDTO: DepartmentDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'departmentDTO' is not null or undefined
            assertParamExists('createDepartment', 'departmentDTO', departmentDTO)
            const localVarPath = `/api/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(departmentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a department by ID
         * @summary Delete department
         * @param {number} id ID of the department to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDepartment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDepartment', 'id', id)
            const localVarPath = `/api/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns departments belonging to a specific group
         * @summary Find departments by group
         * @param {string} group Department group to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDepartmentsByGroup: async (group: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('findDepartmentsByGroup', 'group', group)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findDepartmentsByGroup', 'pageable', pageable)
            const localVarPath = `/api/departments/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns departments matching a specific type
         * @summary Find departments by type
         * @param {number} typeCode Department type code to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDepartmentsByType: async (typeCode: number, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeCode' is not null or undefined
            assertParamExists('findDepartmentsByType', 'typeCode', typeCode)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findDepartmentsByType', 'pageable', pageable)
            const localVarPath = `/api/departments/type/{typeCode}`
                .replace(`{${"typeCode"}}`, encodeURIComponent(String(typeCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all departments
         * @summary Get all departments
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDepartments: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllDepartments', 'pageable', pageable)
            const localVarPath = `/api/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single department by ID
         * @summary Get department by ID
         * @param {number} id ID of the department to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDepartmentById', 'id', id)
            const localVarPath = `/api/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns statistics about departments
         * @summary Get department statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/departments/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of available department types and their descriptions
         * @summary Get department types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/departments/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search departments by name or abbreviation
         * @summary Search departments
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDepartments: async (keyword: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('searchDepartments', 'keyword', keyword)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('searchDepartments', 'pageable', pageable)
            const localVarPath = `/api/departments/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing department
         * @summary Update department
         * @param {number} id ID of the department to update
         * @param {DepartmentDTO} departmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDepartment: async (id: number, departmentDTO: DepartmentDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDepartment', 'id', id)
            // verify required parameter 'departmentDTO' is not null or undefined
            assertParamExists('updateDepartment', 'departmentDTO', departmentDTO)
            const localVarPath = `/api/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(departmentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentsApi - functional programming interface
 * @export
 */
export const DepartmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepartmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new department
         * @summary Create new department
         * @param {DepartmentDTO} departmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepartment(departmentDTO: DepartmentDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepartmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDepartment(departmentDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.createDepartment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a department by ID
         * @summary Delete department
         * @param {number} id ID of the department to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDepartment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDepartment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.deleteDepartment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns departments belonging to a specific group
         * @summary Find departments by group
         * @param {string} group Department group to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDepartmentsByGroup(group: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDepartmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDepartmentsByGroup(group, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.findDepartmentsByGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns departments matching a specific type
         * @summary Find departments by type
         * @param {number} typeCode Department type code to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDepartmentsByType(typeCode: number, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDepartmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDepartmentsByType(typeCode, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.findDepartmentsByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all departments
         * @summary Get all departments
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDepartments(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDepartmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDepartments(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.getAllDepartments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single department by ID
         * @summary Get department by ID
         * @param {number} id ID of the department to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepartmentById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepartmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartmentById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.getDepartmentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns statistics about departments
         * @summary Get department statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepartmentStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartmentStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.getDepartmentStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of available department types and their descriptions
         * @summary Get department types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepartmentTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartmentTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.getDepartmentTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search departments by name or abbreviation
         * @summary Search departments
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDepartments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageDepartmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDepartments(keyword, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.searchDepartments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing department
         * @summary Update department
         * @param {number} id ID of the department to update
         * @param {DepartmentDTO} departmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDepartment(id: number, departmentDTO: DepartmentDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepartmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDepartment(id, departmentDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.updateDepartment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DepartmentsApi - factory interface
 * @export
 */
export const DepartmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepartmentsApiFp(configuration)
    return {
        /**
         * Creates a new department
         * @summary Create new department
         * @param {DepartmentDTO} departmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepartment(departmentDTO: DepartmentDTO, options?: RawAxiosRequestConfig): AxiosPromise<DepartmentDTO> {
            return localVarFp.createDepartment(departmentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a department by ID
         * @summary Delete department
         * @param {number} id ID of the department to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDepartment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDepartment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns departments belonging to a specific group
         * @summary Find departments by group
         * @param {string} group Department group to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDepartmentsByGroup(group: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageDepartmentDTO> {
            return localVarFp.findDepartmentsByGroup(group, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns departments matching a specific type
         * @summary Find departments by type
         * @param {number} typeCode Department type code to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDepartmentsByType(typeCode: number, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageDepartmentDTO> {
            return localVarFp.findDepartmentsByType(typeCode, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all departments
         * @summary Get all departments
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDepartments(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageDepartmentDTO> {
            return localVarFp.getAllDepartments(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single department by ID
         * @summary Get department by ID
         * @param {number} id ID of the department to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DepartmentDTO> {
            return localVarFp.getDepartmentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns statistics about departments
         * @summary Get department statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentStatistics(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getDepartmentStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of available department types and their descriptions
         * @summary Get department types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartmentTypes(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getDepartmentTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Search departments by name or abbreviation
         * @summary Search departments
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDepartments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageDepartmentDTO> {
            return localVarFp.searchDepartments(keyword, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing department
         * @summary Update department
         * @param {number} id ID of the department to update
         * @param {DepartmentDTO} departmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDepartment(id: number, departmentDTO: DepartmentDTO, options?: RawAxiosRequestConfig): AxiosPromise<DepartmentDTO> {
            return localVarFp.updateDepartment(id, departmentDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepartmentsApi - object-oriented interface
 * @export
 * @class DepartmentsApi
 * @extends {BaseAPI}
 */
export class DepartmentsApi extends BaseAPI {
    /**
     * Creates a new department
     * @summary Create new department
     * @param {DepartmentDTO} departmentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public createDepartment(departmentDTO: DepartmentDTO, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).createDepartment(departmentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a department by ID
     * @summary Delete department
     * @param {number} id ID of the department to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public deleteDepartment(id: number, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).deleteDepartment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns departments belonging to a specific group
     * @summary Find departments by group
     * @param {string} group Department group to filter by
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public findDepartmentsByGroup(group: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).findDepartmentsByGroup(group, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns departments matching a specific type
     * @summary Find departments by type
     * @param {number} typeCode Department type code to filter by
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public findDepartmentsByType(typeCode: number, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).findDepartmentsByType(typeCode, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all departments
     * @summary Get all departments
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public getAllDepartments(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).getAllDepartments(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single department by ID
     * @summary Get department by ID
     * @param {number} id ID of the department to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public getDepartmentById(id: number, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).getDepartmentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns statistics about departments
     * @summary Get department statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public getDepartmentStatistics(options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).getDepartmentStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of available department types and their descriptions
     * @summary Get department types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public getDepartmentTypes(options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).getDepartmentTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search departments by name or abbreviation
     * @summary Search departments
     * @param {string} keyword Keyword to search for
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public searchDepartments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).searchDepartments(keyword, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing department
     * @summary Update department
     * @param {number} id ID of the department to update
     * @param {DepartmentDTO} departmentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public updateDepartment(id: number, departmentDTO: DepartmentDTO, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).updateDepartment(id, departmentDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentWorkflowApi - axios parameter creator
 * @export
 */
export const DocumentWorkflowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Leader approves document
         * @summary Approve document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveDocument: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('approveDocument', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('approveDocument', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/approve`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns a document to a user
         * @summary Assign document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDocument: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('assignDocument', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('assignDocument', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/assign`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Department head assigns document to a specialist
         * @summary Assign to specialist
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignToSpecialist: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('assignToSpecialist', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('assignToSpecialist', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/assign-specialist`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the status of a document in the workflow
         * @summary Change document status
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDocumentStatus: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('changeDocumentStatus', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('changeDocumentStatus', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/status`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Distribute document to relevant departments
         * @summary Distribute document
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributeDocument: async (documentId: number, requestBody: { [key: string]: object; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('distributeDocument', 'documentId', documentId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('distributeDocument', 'requestBody', requestBody)
            const localVarPath = `/api/workflow/{documentId}/distribute`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Department head forwards document for leader approval
         * @summary Forward to leadership
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardToLeadership: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('forwardToLeadership', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('forwardToLeadership', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/forward-to-leadership`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get departments assigned to process a document
         * @summary Get document departments
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentDepartments: async (documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentDepartments', 'documentId', documentId)
            const localVarPath = `/api/workflow/{documentId}/departments`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the workflow history of a document
         * @summary Get document history
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentHistory: async (documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentHistory', 'documentId', documentId)
            const localVarPath = `/api/workflow/{documentId}/history`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current status of a document
         * @summary Get document status
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentStatus: async (documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentStatus', 'documentId', documentId)
            const localVarPath = `/api/workflow/{documentId}/status`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Leader provides feedback on document
         * @summary Provide feedback
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provideDocumentFeedback: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('provideDocumentFeedback', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('provideDocumentFeedback', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/provide-feedback`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Văn thư publishes an outgoing document
         * @summary Publish outgoing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOutgoingDocument: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('publishOutgoingDocument', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('publishOutgoingDocument', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/publish`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Văn thư registers a newly received document
         * @summary Register incoming document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerIncomingDocument: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('registerIncomingDocument', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('registerIncomingDocument', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/register`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specialist starts processing the document
         * @summary Start processing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessingDocument: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('startProcessingDocument', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('startProcessingDocument', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/start-processing`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Leader starts reviewing document
         * @summary Start reviewing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startReviewingDocument: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('startReviewingDocument', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('startReviewingDocument', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/start-reviewing`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specialist submits document for leader approval
         * @summary Submit to leadership
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitToLeadership: async (documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('submitToLeadership', 'documentId', documentId)
            // verify required parameter 'documentWorkflowDTO' is not null or undefined
            assertParamExists('submitToLeadership', 'documentWorkflowDTO', documentWorkflowDTO)
            const localVarPath = `/api/workflow/{documentId}/submit`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentWorkflowDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentWorkflowApi - functional programming interface
 * @export
 */
export const DocumentWorkflowApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentWorkflowApiAxiosParamCreator(configuration)
    return {
        /**
         * Leader approves document
         * @summary Approve document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveDocument(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.approveDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assigns a document to a user
         * @summary Assign document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignDocument(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.assignDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Department head assigns document to a specialist
         * @summary Assign to specialist
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignToSpecialist(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignToSpecialist(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.assignToSpecialist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the status of a document in the workflow
         * @summary Change document status
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDocumentStatus(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDocumentStatus(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.changeDocumentStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Distribute document to relevant departments
         * @summary Distribute document
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributeDocument(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributeDocument(documentId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.distributeDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Department head forwards document for leader approval
         * @summary Forward to leadership
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forwardToLeadership(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardToLeadership(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.forwardToLeadership']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get departments assigned to process a document
         * @summary Get document departments
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentDepartments(documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentDepartmentDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentDepartments(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.getDocumentDepartments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the workflow history of a document
         * @summary Get document history
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentHistory(documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentHistoryDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentHistory(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.getDocumentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current status of a document
         * @summary Get document status
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentStatus(documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentWorkflowDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentStatus(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.getDocumentStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Leader provides feedback on document
         * @summary Provide feedback
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provideDocumentFeedback(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provideDocumentFeedback(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.provideDocumentFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Văn thư publishes an outgoing document
         * @summary Publish outgoing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishOutgoingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishOutgoingDocument(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.publishOutgoingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Văn thư registers a newly received document
         * @summary Register incoming document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerIncomingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerIncomingDocument(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.registerIncomingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specialist starts processing the document
         * @summary Start processing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcessingDocument(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.startProcessingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Leader starts reviewing document
         * @summary Start reviewing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startReviewingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startReviewingDocument(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.startReviewingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Specialist submits document for leader approval
         * @summary Submit to leadership
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitToLeadership(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitToLeadership(documentId, documentWorkflowDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentWorkflowApi.submitToLeadership']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentWorkflowApi - factory interface
 * @export
 */
export const DocumentWorkflowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentWorkflowApiFp(configuration)
    return {
        /**
         * Leader approves document
         * @summary Approve document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.approveDocument(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns a document to a user
         * @summary Assign document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.assignDocument(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Department head assigns document to a specialist
         * @summary Assign to specialist
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignToSpecialist(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.assignToSpecialist(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the status of a document in the workflow
         * @summary Change document status
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDocumentStatus(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.changeDocumentStatus(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Distribute document to relevant departments
         * @summary Distribute document
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributeDocument(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.distributeDocument(documentId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Department head forwards document for leader approval
         * @summary Forward to leadership
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardToLeadership(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.forwardToLeadership(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get departments assigned to process a document
         * @summary Get document departments
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentDepartments(documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentDepartmentDTO>> {
            return localVarFp.getDocumentDepartments(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the workflow history of a document
         * @summary Get document history
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentHistory(documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentHistoryDTO>> {
            return localVarFp.getDocumentHistory(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current status of a document
         * @summary Get document status
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentStatus(documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentWorkflowDTO> {
            return localVarFp.getDocumentStatus(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Leader provides feedback on document
         * @summary Provide feedback
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provideDocumentFeedback(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.provideDocumentFeedback(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Văn thư publishes an outgoing document
         * @summary Publish outgoing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOutgoingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.publishOutgoingDocument(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Văn thư registers a newly received document
         * @summary Register incoming document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerIncomingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.registerIncomingDocument(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Specialist starts processing the document
         * @summary Start processing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startProcessingDocument(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Leader starts reviewing document
         * @summary Start reviewing document
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startReviewingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startReviewingDocument(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Specialist submits document for leader approval
         * @summary Submit to leadership
         * @param {number} documentId ID of the document
         * @param {DocumentWorkflowDTO} documentWorkflowDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitToLeadership(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.submitToLeadership(documentId, documentWorkflowDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentWorkflowApi - object-oriented interface
 * @export
 * @class DocumentWorkflowApi
 * @extends {BaseAPI}
 */
export class DocumentWorkflowApi extends BaseAPI {
    /**
     * Leader approves document
     * @summary Approve document
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public approveDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).approveDocument(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns a document to a user
     * @summary Assign document
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public assignDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).assignDocument(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Department head assigns document to a specialist
     * @summary Assign to specialist
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public assignToSpecialist(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).assignToSpecialist(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the status of a document in the workflow
     * @summary Change document status
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public changeDocumentStatus(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).changeDocumentStatus(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Distribute document to relevant departments
     * @summary Distribute document
     * @param {number} documentId ID of the document
     * @param {{ [key: string]: object; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public distributeDocument(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).distributeDocument(documentId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Department head forwards document for leader approval
     * @summary Forward to leadership
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public forwardToLeadership(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).forwardToLeadership(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get departments assigned to process a document
     * @summary Get document departments
     * @param {number} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public getDocumentDepartments(documentId: number, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).getDocumentDepartments(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the workflow history of a document
     * @summary Get document history
     * @param {number} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public getDocumentHistory(documentId: number, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).getDocumentHistory(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current status of a document
     * @summary Get document status
     * @param {number} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public getDocumentStatus(documentId: number, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).getDocumentStatus(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Leader provides feedback on document
     * @summary Provide feedback
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public provideDocumentFeedback(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).provideDocumentFeedback(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Văn thư publishes an outgoing document
     * @summary Publish outgoing document
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public publishOutgoingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).publishOutgoingDocument(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Văn thư registers a newly received document
     * @summary Register incoming document
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public registerIncomingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).registerIncomingDocument(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specialist starts processing the document
     * @summary Start processing document
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public startProcessingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).startProcessingDocument(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Leader starts reviewing document
     * @summary Start reviewing document
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public startReviewingDocument(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).startReviewingDocument(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specialist submits document for leader approval
     * @summary Submit to leadership
     * @param {number} documentId ID of the document
     * @param {DocumentWorkflowDTO} documentWorkflowDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentWorkflowApi
     */
    public submitToLeadership(documentId: number, documentWorkflowDTO: DocumentWorkflowDTO, options?: RawAxiosRequestConfig) {
        return DocumentWorkflowApiFp(this.configuration).submitToLeadership(documentId, documentWorkflowDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IncomingDocumentsApi - axios parameter creator
 * @export
 */
export const IncomingDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new incoming document
         * @summary Create new incoming document
         * @param {IncomingDocumentDTO} incomingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncomingDocument: async (incomingDocumentDTO: IncomingDocumentDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incomingDocumentDTO' is not null or undefined
            assertParamExists('createIncomingDocument', 'incomingDocumentDTO', incomingDocumentDTO)
            const localVarPath = `/api/documents/incoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incomingDocumentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an incoming document by ID
         * @summary Delete incoming document
         * @param {number} id ID of the document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIncomingDocument: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIncomingDocument', 'id', id)
            const localVarPath = `/api/documents/incoming/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a file attachment for an incoming document
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIncomingDocumentAttachment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadIncomingDocumentAttachment', 'id', id)
            const localVarPath = `/api/documents/incoming/{id}/attachment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns documents within a specific date range
         * @summary Find documents by date range
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByDateRange2: async (start: string, end: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('findByDateRange2', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('findByDateRange2', 'end', end)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findByDateRange2', 'pageable', pageable)
            const localVarPath = `/api/documents/incoming/date-range`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns documents with a specific processing status
         * @summary Find documents by processing status
         * @param {string} status Processing status to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByProcessingStatus: async (status: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('findByProcessingStatus', 'status', status)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findByProcessingStatus', 'pageable', pageable)
            const localVarPath = `/api/documents/incoming/processing-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns documents matching a specific urgency level
         * @summary Find documents by urgency level
         * @param {string} level Urgency level to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUrgencyLevel: async (level: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'level' is not null or undefined
            assertParamExists('findByUrgencyLevel', 'level', level)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findByUrgencyLevel', 'pageable', pageable)
            const localVarPath = `/api/documents/incoming/urgency-level`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all incoming documents
         * @summary Get all incoming documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIncomingDocuments: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllIncomingDocuments', 'pageable', pageable)
            const localVarPath = `/api/documents/incoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single incoming document by ID
         * @summary Get incoming document by ID
         * @param {number} id ID of the document to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomingDocumentById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIncomingDocumentById', 'id', id)
            const localVarPath = `/api/documents/incoming/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search incoming documents by keyword
         * @summary Search incoming documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchIncomingDocuments: async (keyword: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('searchIncomingDocuments', 'keyword', keyword)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('searchIncomingDocuments', 'pageable', pageable)
            const localVarPath = `/api/documents/incoming/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing incoming document
         * @summary Update incoming document
         * @param {number} id ID of the document to update
         * @param {IncomingDocumentDTO} incomingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIncomingDocument: async (id: number, incomingDocumentDTO: IncomingDocumentDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIncomingDocument', 'id', id)
            // verify required parameter 'incomingDocumentDTO' is not null or undefined
            assertParamExists('updateIncomingDocument', 'incomingDocumentDTO', incomingDocumentDTO)
            const localVarPath = `/api/documents/incoming/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incomingDocumentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file attachment for an incoming document
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIncomingDocumentAttachment: async (id: number, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadIncomingDocumentAttachment', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadIncomingDocumentAttachment', 'file', file)
            const localVarPath = `/api/documents/incoming/{id}/attachment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncomingDocumentsApi - functional programming interface
 * @export
 */
export const IncomingDocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IncomingDocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new incoming document
         * @summary Create new incoming document
         * @param {IncomingDocumentDTO} incomingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIncomingDocument(incomingDocumentDTO: IncomingDocumentDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIncomingDocument(incomingDocumentDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.createIncomingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an incoming document by ID
         * @summary Delete incoming document
         * @param {number} id ID of the document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIncomingDocument(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIncomingDocument(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.deleteIncomingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads a file attachment for an incoming document
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadIncomingDocumentAttachment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadIncomingDocumentAttachment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.downloadIncomingDocumentAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns documents within a specific date range
         * @summary Find documents by date range
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByDateRange2(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageIncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByDateRange2(start, end, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.findByDateRange2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns documents with a specific processing status
         * @summary Find documents by processing status
         * @param {string} status Processing status to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByProcessingStatus(status: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageIncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByProcessingStatus(status, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.findByProcessingStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns documents matching a specific urgency level
         * @summary Find documents by urgency level
         * @param {string} level Urgency level to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByUrgencyLevel(level: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageIncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByUrgencyLevel(level, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.findByUrgencyLevel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all incoming documents
         * @summary Get all incoming documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllIncomingDocuments(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageIncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllIncomingDocuments(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.getAllIncomingDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single incoming document by ID
         * @summary Get incoming document by ID
         * @param {number} id ID of the document to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomingDocumentById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomingDocumentById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.getIncomingDocumentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search incoming documents by keyword
         * @summary Search incoming documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchIncomingDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageIncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchIncomingDocuments(keyword, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.searchIncomingDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing incoming document
         * @summary Update incoming document
         * @param {number} id ID of the document to update
         * @param {IncomingDocumentDTO} incomingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIncomingDocument(id: number, incomingDocumentDTO: IncomingDocumentDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIncomingDocument(id, incomingDocumentDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.updateIncomingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file attachment for an incoming document
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadIncomingDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncomingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadIncomingDocumentAttachment(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomingDocumentsApi.uploadIncomingDocumentAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IncomingDocumentsApi - factory interface
 * @export
 */
export const IncomingDocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IncomingDocumentsApiFp(configuration)
    return {
        /**
         * Creates a new incoming document
         * @summary Create new incoming document
         * @param {IncomingDocumentDTO} incomingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncomingDocument(incomingDocumentDTO: IncomingDocumentDTO, options?: RawAxiosRequestConfig): AxiosPromise<IncomingDocumentDTO> {
            return localVarFp.createIncomingDocument(incomingDocumentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an incoming document by ID
         * @summary Delete incoming document
         * @param {number} id ID of the document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIncomingDocument(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteIncomingDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a file attachment for an incoming document
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIncomingDocumentAttachment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadIncomingDocumentAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns documents within a specific date range
         * @summary Find documents by date range
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByDateRange2(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageIncomingDocumentDTO> {
            return localVarFp.findByDateRange2(start, end, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns documents with a specific processing status
         * @summary Find documents by processing status
         * @param {string} status Processing status to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByProcessingStatus(status: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageIncomingDocumentDTO> {
            return localVarFp.findByProcessingStatus(status, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns documents matching a specific urgency level
         * @summary Find documents by urgency level
         * @param {string} level Urgency level to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUrgencyLevel(level: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageIncomingDocumentDTO> {
            return localVarFp.findByUrgencyLevel(level, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all incoming documents
         * @summary Get all incoming documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIncomingDocuments(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageIncomingDocumentDTO> {
            return localVarFp.getAllIncomingDocuments(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single incoming document by ID
         * @summary Get incoming document by ID
         * @param {number} id ID of the document to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomingDocumentById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<IncomingDocumentDTO> {
            return localVarFp.getIncomingDocumentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Search incoming documents by keyword
         * @summary Search incoming documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchIncomingDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageIncomingDocumentDTO> {
            return localVarFp.searchIncomingDocuments(keyword, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing incoming document
         * @summary Update incoming document
         * @param {number} id ID of the document to update
         * @param {IncomingDocumentDTO} incomingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIncomingDocument(id: number, incomingDocumentDTO: IncomingDocumentDTO, options?: RawAxiosRequestConfig): AxiosPromise<IncomingDocumentDTO> {
            return localVarFp.updateIncomingDocument(id, incomingDocumentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file attachment for an incoming document
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIncomingDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig): AxiosPromise<IncomingDocumentDTO> {
            return localVarFp.uploadIncomingDocumentAttachment(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IncomingDocumentsApi - object-oriented interface
 * @export
 * @class IncomingDocumentsApi
 * @extends {BaseAPI}
 */
export class IncomingDocumentsApi extends BaseAPI {
    /**
     * Creates a new incoming document
     * @summary Create new incoming document
     * @param {IncomingDocumentDTO} incomingDocumentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public createIncomingDocument(incomingDocumentDTO: IncomingDocumentDTO, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).createIncomingDocument(incomingDocumentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an incoming document by ID
     * @summary Delete incoming document
     * @param {number} id ID of the document to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public deleteIncomingDocument(id: number, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).deleteIncomingDocument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads a file attachment for an incoming document
     * @summary Download document attachment
     * @param {number} id ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public downloadIncomingDocumentAttachment(id: number, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).downloadIncomingDocumentAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns documents within a specific date range
     * @summary Find documents by date range
     * @param {string} start Start date (ISO format)
     * @param {string} end End date (ISO format)
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public findByDateRange2(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).findByDateRange2(start, end, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns documents with a specific processing status
     * @summary Find documents by processing status
     * @param {string} status Processing status to filter by
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public findByProcessingStatus(status: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).findByProcessingStatus(status, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns documents matching a specific urgency level
     * @summary Find documents by urgency level
     * @param {string} level Urgency level to filter by
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public findByUrgencyLevel(level: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).findByUrgencyLevel(level, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all incoming documents
     * @summary Get all incoming documents
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public getAllIncomingDocuments(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).getAllIncomingDocuments(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single incoming document by ID
     * @summary Get incoming document by ID
     * @param {number} id ID of the document to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public getIncomingDocumentById(id: number, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).getIncomingDocumentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search incoming documents by keyword
     * @summary Search incoming documents
     * @param {string} keyword Keyword to search for
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public searchIncomingDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).searchIncomingDocuments(keyword, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing incoming document
     * @summary Update incoming document
     * @param {number} id ID of the document to update
     * @param {IncomingDocumentDTO} incomingDocumentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public updateIncomingDocument(id: number, incomingDocumentDTO: IncomingDocumentDTO, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).updateIncomingDocument(id, incomingDocumentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file attachment for an incoming document
     * @summary Upload document attachment
     * @param {number} id ID of the document
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncomingDocumentsApi
     */
    public uploadIncomingDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig) {
        return IncomingDocumentsApiFp(this.configuration).uploadIncomingDocumentAttachment(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OutgoingDocumentsApi - axios parameter creator
 * @export
 */
export const OutgoingDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new outgoing document
         * @summary Create new outgoing document
         * @param {OutgoingDocumentDTO} outgoingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOutgoingDocument: async (outgoingDocumentDTO: OutgoingDocumentDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outgoingDocumentDTO' is not null or undefined
            assertParamExists('createOutgoingDocument', 'outgoingDocumentDTO', outgoingDocumentDTO)
            const localVarPath = `/api/documents/outgoing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outgoingDocumentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an outgoing document by ID
         * @summary Delete outgoing document
         * @param {number} id ID of the document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOutgoingDocument: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOutgoingDocument', 'id', id)
            const localVarPath = `/api/documents/outgoing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a file attachment for an outgoing document
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOutgoingDocumentAttachment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadOutgoingDocumentAttachment', 'id', id)
            const localVarPath = `/api/documents/outgoing/{id}/attachment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns documents within a specific date range
         * @summary Find documents by date range
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByDateRange1: async (start: string, end: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('findByDateRange1', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('findByDateRange1', 'end', end)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findByDateRange1', 'pageable', pageable)
            const localVarPath = `/api/documents/outgoing/date-range`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns documents matching a specific document type
         * @summary Find documents by type
         * @param {string} type Document type to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByDocumentType: async (type: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('findByDocumentType', 'type', type)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findByDocumentType', 'pageable', pageable)
            const localVarPath = `/api/documents/outgoing/document-type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all outgoing documents
         * @summary Get all outgoing documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOutgoingDocuments: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllOutgoingDocuments', 'pageable', pageable)
            const localVarPath = `/api/documents/outgoing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single outgoing document by ID
         * @summary Get outgoing document by ID
         * @param {number} id ID of the document to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutgoingDocumentById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOutgoingDocumentById', 'id', id)
            const localVarPath = `/api/documents/outgoing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search outgoing documents by keyword
         * @summary Search outgoing documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOutgoingDocuments: async (keyword: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('searchOutgoingDocuments', 'keyword', keyword)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('searchOutgoingDocuments', 'pageable', pageable)
            const localVarPath = `/api/documents/outgoing/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing outgoing document
         * @summary Update outgoing document
         * @param {number} id ID of the document to update
         * @param {OutgoingDocumentDTO} outgoingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOutgoingDocument: async (id: number, outgoingDocumentDTO: OutgoingDocumentDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOutgoingDocument', 'id', id)
            // verify required parameter 'outgoingDocumentDTO' is not null or undefined
            assertParamExists('updateOutgoingDocument', 'outgoingDocumentDTO', outgoingDocumentDTO)
            const localVarPath = `/api/documents/outgoing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outgoingDocumentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads multiple file attachments for an outgoing document
         * @summary Upload multiple document attachments
         * @param {number} id ID of the document
         * @param {Array<File>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipleAttachments1: async (id: number, files: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadMultipleAttachments1', 'id', id)
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadMultipleAttachments1', 'files', files)
            const localVarPath = `/api/documents/outgoing/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file attachment for an outgoing document
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOutgoingDocumentAttachment: async (id: number, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadOutgoingDocumentAttachment', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadOutgoingDocumentAttachment', 'file', file)
            const localVarPath = `/api/documents/outgoing/{id}/attachment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OutgoingDocumentsApi - functional programming interface
 * @export
 */
export const OutgoingDocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OutgoingDocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new outgoing document
         * @summary Create new outgoing document
         * @param {OutgoingDocumentDTO} outgoingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOutgoingDocument(outgoingDocumentDTO: OutgoingDocumentDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutgoingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOutgoingDocument(outgoingDocumentDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.createOutgoingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an outgoing document by ID
         * @summary Delete outgoing document
         * @param {number} id ID of the document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOutgoingDocument(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOutgoingDocument(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.deleteOutgoingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads a file attachment for an outgoing document
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadOutgoingDocumentAttachment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadOutgoingDocumentAttachment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.downloadOutgoingDocumentAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns documents within a specific date range
         * @summary Find documents by date range
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByDateRange1(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOutgoingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByDateRange1(start, end, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.findByDateRange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns documents matching a specific document type
         * @summary Find documents by type
         * @param {string} type Document type to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByDocumentType(type: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOutgoingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByDocumentType(type, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.findByDocumentType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all outgoing documents
         * @summary Get all outgoing documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOutgoingDocuments(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOutgoingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOutgoingDocuments(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.getAllOutgoingDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single outgoing document by ID
         * @summary Get outgoing document by ID
         * @param {number} id ID of the document to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOutgoingDocumentById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutgoingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOutgoingDocumentById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.getOutgoingDocumentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search outgoing documents by keyword
         * @summary Search outgoing documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchOutgoingDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOutgoingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchOutgoingDocuments(keyword, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.searchOutgoingDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing outgoing document
         * @summary Update outgoing document
         * @param {number} id ID of the document to update
         * @param {OutgoingDocumentDTO} outgoingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOutgoingDocument(id: number, outgoingDocumentDTO: OutgoingDocumentDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutgoingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOutgoingDocument(id, outgoingDocumentDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.updateOutgoingDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads multiple file attachments for an outgoing document
         * @summary Upload multiple document attachments
         * @param {number} id ID of the document
         * @param {Array<File>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMultipleAttachments1(id: number, files: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMultipleAttachments1(id, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.uploadMultipleAttachments1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file attachment for an outgoing document
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadOutgoingDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutgoingDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadOutgoingDocumentAttachment(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutgoingDocumentsApi.uploadOutgoingDocumentAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OutgoingDocumentsApi - factory interface
 * @export
 */
export const OutgoingDocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OutgoingDocumentsApiFp(configuration)
    return {
        /**
         * Creates a new outgoing document
         * @summary Create new outgoing document
         * @param {OutgoingDocumentDTO} outgoingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOutgoingDocument(outgoingDocumentDTO: OutgoingDocumentDTO, options?: RawAxiosRequestConfig): AxiosPromise<OutgoingDocumentDTO> {
            return localVarFp.createOutgoingDocument(outgoingDocumentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an outgoing document by ID
         * @summary Delete outgoing document
         * @param {number} id ID of the document to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOutgoingDocument(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOutgoingDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a file attachment for an outgoing document
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOutgoingDocumentAttachment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadOutgoingDocumentAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns documents within a specific date range
         * @summary Find documents by date range
         * @param {string} start Start date (ISO format)
         * @param {string} end End date (ISO format)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByDateRange1(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageOutgoingDocumentDTO> {
            return localVarFp.findByDateRange1(start, end, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns documents matching a specific document type
         * @summary Find documents by type
         * @param {string} type Document type to filter by
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByDocumentType(type: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageOutgoingDocumentDTO> {
            return localVarFp.findByDocumentType(type, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all outgoing documents
         * @summary Get all outgoing documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOutgoingDocuments(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageOutgoingDocumentDTO> {
            return localVarFp.getAllOutgoingDocuments(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single outgoing document by ID
         * @summary Get outgoing document by ID
         * @param {number} id ID of the document to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutgoingDocumentById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<OutgoingDocumentDTO> {
            return localVarFp.getOutgoingDocumentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Search outgoing documents by keyword
         * @summary Search outgoing documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOutgoingDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageOutgoingDocumentDTO> {
            return localVarFp.searchOutgoingDocuments(keyword, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing outgoing document
         * @summary Update outgoing document
         * @param {number} id ID of the document to update
         * @param {OutgoingDocumentDTO} outgoingDocumentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOutgoingDocument(id: number, outgoingDocumentDTO: OutgoingDocumentDTO, options?: RawAxiosRequestConfig): AxiosPromise<OutgoingDocumentDTO> {
            return localVarFp.updateOutgoingDocument(id, outgoingDocumentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads multiple file attachments for an outgoing document
         * @summary Upload multiple document attachments
         * @param {number} id ID of the document
         * @param {Array<File>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipleAttachments1(id: number, files: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.uploadMultipleAttachments1(id, files, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file attachment for an outgoing document
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOutgoingDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig): AxiosPromise<OutgoingDocumentDTO> {
            return localVarFp.uploadOutgoingDocumentAttachment(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OutgoingDocumentsApi - object-oriented interface
 * @export
 * @class OutgoingDocumentsApi
 * @extends {BaseAPI}
 */
export class OutgoingDocumentsApi extends BaseAPI {
    /**
     * Creates a new outgoing document
     * @summary Create new outgoing document
     * @param {OutgoingDocumentDTO} outgoingDocumentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public createOutgoingDocument(outgoingDocumentDTO: OutgoingDocumentDTO, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).createOutgoingDocument(outgoingDocumentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an outgoing document by ID
     * @summary Delete outgoing document
     * @param {number} id ID of the document to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public deleteOutgoingDocument(id: number, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).deleteOutgoingDocument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads a file attachment for an outgoing document
     * @summary Download document attachment
     * @param {number} id ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public downloadOutgoingDocumentAttachment(id: number, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).downloadOutgoingDocumentAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns documents within a specific date range
     * @summary Find documents by date range
     * @param {string} start Start date (ISO format)
     * @param {string} end End date (ISO format)
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public findByDateRange1(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).findByDateRange1(start, end, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns documents matching a specific document type
     * @summary Find documents by type
     * @param {string} type Document type to filter by
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public findByDocumentType(type: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).findByDocumentType(type, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all outgoing documents
     * @summary Get all outgoing documents
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public getAllOutgoingDocuments(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).getAllOutgoingDocuments(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single outgoing document by ID
     * @summary Get outgoing document by ID
     * @param {number} id ID of the document to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public getOutgoingDocumentById(id: number, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).getOutgoingDocumentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search outgoing documents by keyword
     * @summary Search outgoing documents
     * @param {string} keyword Keyword to search for
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public searchOutgoingDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).searchOutgoingDocuments(keyword, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing outgoing document
     * @summary Update outgoing document
     * @param {number} id ID of the document to update
     * @param {OutgoingDocumentDTO} outgoingDocumentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public updateOutgoingDocument(id: number, outgoingDocumentDTO: OutgoingDocumentDTO, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).updateOutgoingDocument(id, outgoingDocumentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads multiple file attachments for an outgoing document
     * @summary Upload multiple document attachments
     * @param {number} id ID of the document
     * @param {Array<File>} files Files to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public uploadMultipleAttachments1(id: number, files: Array<File>, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).uploadMultipleAttachments1(id, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file attachment for an outgoing document
     * @summary Upload document attachment
     * @param {number} id ID of the document
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutgoingDocumentsApi
     */
    public uploadOutgoingDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig) {
        return OutgoingDocumentsApiFp(this.configuration).uploadOutgoingDocumentAttachment(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new custom permission
         * @summary Create a new permission
         * @param {PermissionDTO} permissionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermission: async (permissionDTO: PermissionDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionDTO' is not null or undefined
            assertParamExists('createPermission', 'permissionDTO', permissionDTO)
            const localVarPath = `/api/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissionDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom permission
         * @summary Delete a permission
         * @param {number} id ID of the permission to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePermission', 'id', id)
            const localVarPath = `/api/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all permissions
         * @summary Get all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all custom permissions
         * @summary Get custom permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/permissions/custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single permission by ID
         * @summary Get permission by ID
         * @param {number} id ID of the permission to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermissionById', 'id', id)
            const localVarPath = `/api/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single permission by name
         * @summary Get permission by name
         * @param {string} name Name of the permission to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionByName: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPermissionByName', 'name', name)
            const localVarPath = `/api/permissions/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns permissions filtered by category
         * @summary Get permissions by category
         * @param {string} category Category to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsByCategory: async (category: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('getPermissionsByCategory', 'category', category)
            const localVarPath = `/api/permissions/category/{category}`
                .replace(`{${"category"}}`, encodeURIComponent(String(category)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all system permissions
         * @summary Get system permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/permissions/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing custom permission
         * @summary Update a permission
         * @param {number} id ID of the permission to update
         * @param {PermissionDTO} permissionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission: async (id: number, permissionDTO: PermissionDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePermission', 'id', id)
            // verify required parameter 'permissionDTO' is not null or undefined
            assertParamExists('updatePermission', 'permissionDTO', permissionDTO)
            const localVarPath = `/api/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissionDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new custom permission
         * @summary Create a new permission
         * @param {PermissionDTO} permissionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPermission(permissionDTO: PermissionDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPermission(permissionDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.createPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a custom permission
         * @summary Delete a permission
         * @param {number} id ID of the permission to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermission(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermission(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.deletePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all permissions
         * @summary Get all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getAllPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all custom permissions
         * @summary Get custom permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getCustomPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single permission by ID
         * @summary Get permission by ID
         * @param {number} id ID of the permission to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getPermissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single permission by name
         * @summary Get permission by name
         * @param {string} name Name of the permission to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionByName(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getPermissionByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns permissions filtered by category
         * @summary Get permissions by category
         * @param {string} category Category to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionsByCategory(category: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionsByCategory(category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getPermissionsByCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all system permissions
         * @summary Get system permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getSystemPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing custom permission
         * @summary Update a permission
         * @param {number} id ID of the permission to update
         * @param {PermissionDTO} permissionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermission(id: number, permissionDTO: PermissionDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermission(id, permissionDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.updatePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * Creates a new custom permission
         * @summary Create a new permission
         * @param {PermissionDTO} permissionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermission(permissionDTO: PermissionDTO, options?: RawAxiosRequestConfig): AxiosPromise<PermissionDTO> {
            return localVarFp.createPermission(permissionDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a custom permission
         * @summary Delete a permission
         * @param {number} id ID of the permission to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePermission(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all permissions
         * @summary Get all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPermissions(options?: RawAxiosRequestConfig): AxiosPromise<Array<PermissionDTO>> {
            return localVarFp.getAllPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all custom permissions
         * @summary Get custom permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomPermissions(options?: RawAxiosRequestConfig): AxiosPromise<Array<PermissionDTO>> {
            return localVarFp.getCustomPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single permission by ID
         * @summary Get permission by ID
         * @param {number} id ID of the permission to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<PermissionDTO> {
            return localVarFp.getPermissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single permission by name
         * @summary Get permission by name
         * @param {string} name Name of the permission to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionByName(name: string, options?: RawAxiosRequestConfig): AxiosPromise<PermissionDTO> {
            return localVarFp.getPermissionByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns permissions filtered by category
         * @summary Get permissions by category
         * @param {string} category Category to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsByCategory(category: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PermissionDTO>> {
            return localVarFp.getPermissionsByCategory(category, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all system permissions
         * @summary Get system permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemPermissions(options?: RawAxiosRequestConfig): AxiosPromise<Array<PermissionDTO>> {
            return localVarFp.getSystemPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing custom permission
         * @summary Update a permission
         * @param {number} id ID of the permission to update
         * @param {PermissionDTO} permissionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission(id: number, permissionDTO: PermissionDTO, options?: RawAxiosRequestConfig): AxiosPromise<PermissionDTO> {
            return localVarFp.updatePermission(id, permissionDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * Creates a new custom permission
     * @summary Create a new permission
     * @param {PermissionDTO} permissionDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public createPermission(permissionDTO: PermissionDTO, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).createPermission(permissionDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a custom permission
     * @summary Delete a permission
     * @param {number} id ID of the permission to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public deletePermission(id: number, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).deletePermission(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all permissions
     * @summary Get all permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getAllPermissions(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getAllPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all custom permissions
     * @summary Get custom permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getCustomPermissions(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getCustomPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single permission by ID
     * @summary Get permission by ID
     * @param {number} id ID of the permission to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getPermissionById(id: number, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getPermissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single permission by name
     * @summary Get permission by name
     * @param {string} name Name of the permission to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getPermissionByName(name: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getPermissionByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns permissions filtered by category
     * @summary Get permissions by category
     * @param {string} category Category to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getPermissionsByCategory(category: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getPermissionsByCategory(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all system permissions
     * @summary Get system permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getSystemPermissions(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getSystemPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing custom permission
     * @summary Update a permission
     * @param {number} id ID of the permission to update
     * @param {PermissionDTO} permissionDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public updatePermission(id: number, permissionDTO: PermissionDTO, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).updatePermission(id, permissionDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a permission to a role
         * @summary Add permission to role
         * @param {number} roleId ID of the role
         * @param {number} permissionId ID of the permission to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToRole: async (roleId: number, permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('addPermissionToRole', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('addPermissionToRole', 'permissionId', permissionId)
            const localVarPath = `/api/roles/{roleId}/permissions/{permissionId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new custom role
         * @summary Create a new role
         * @param {CustomRoleDTO} customRoleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (customRoleDTO: CustomRoleDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleDTO' is not null or undefined
            assertParamExists('createRole', 'customRoleDTO', customRoleDTO)
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customRoleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom role
         * @summary Delete a role
         * @param {number} id ID of the role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all roles
         * @summary Get all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all custom roles
         * @summary Get custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/roles/custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single role by ID
         * @summary Get role by ID
         * @param {number} id ID of the role to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoleById', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single role by name
         * @summary Get role by name
         * @param {string} name Name of the role to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleByName: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoleByName', 'name', name)
            const localVarPath = `/api/roles/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns roles created by a specific user
         * @summary Get roles by creator
         * @param {number} creatorId ID of the creator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByCreator: async (creatorId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creatorId' is not null or undefined
            assertParamExists('getRolesByCreator', 'creatorId', creatorId)
            const localVarPath = `/api/roles/creator/{creatorId}`
                .replace(`{${"creatorId"}}`, encodeURIComponent(String(creatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns roles that have a specific permission
         * @summary Get roles by permission
         * @param {string} permissionName Name of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByPermission: async (permissionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionName' is not null or undefined
            assertParamExists('getRolesByPermission', 'permissionName', permissionName)
            const localVarPath = `/api/roles/by-permission/{permissionName}`
                .replace(`{${"permissionName"}}`, encodeURIComponent(String(permissionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all system roles
         * @summary Get system roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/roles/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a permission from a role
         * @summary Remove permission from role
         * @param {number} roleId ID of the role
         * @param {number} permissionId ID of the permission to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromRole: async (roleId: number, permissionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('removePermissionFromRole', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('removePermissionFromRole', 'permissionId', permissionId)
            const localVarPath = `/api/roles/{roleId}/permissions/{permissionId}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing custom role
         * @summary Update a role
         * @param {number} id ID of the role to update
         * @param {CustomRoleDTO} customRoleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (id: number, customRoleDTO: CustomRoleDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRole', 'id', id)
            // verify required parameter 'customRoleDTO' is not null or undefined
            assertParamExists('updateRole', 'customRoleDTO', customRoleDTO)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customRoleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a permission to a role
         * @summary Add permission to role
         * @param {number} roleId ID of the role
         * @param {number} permissionId ID of the permission to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPermissionToRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPermissionToRole(roleId, permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.addPermissionToRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new custom role
         * @summary Create a new role
         * @param {CustomRoleDTO} customRoleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(customRoleDTO: CustomRoleDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(customRoleDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a custom role
         * @summary Delete a role
         * @param {number} id ID of the role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all roles
         * @summary Get all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomRoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getAllRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all custom roles
         * @summary Get custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomRoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getCustomRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single role by ID
         * @summary Get role by ID
         * @param {number} id ID of the role to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single role by name
         * @summary Get role by name
         * @param {string} name Name of the role to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleByName(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRoleByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns roles created by a specific user
         * @summary Get roles by creator
         * @param {number} creatorId ID of the creator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRolesByCreator(creatorId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomRoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesByCreator(creatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRolesByCreator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns roles that have a specific permission
         * @summary Get roles by permission
         * @param {string} permissionName Name of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRolesByPermission(permissionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomRoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesByPermission(permissionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRolesByPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all system roles
         * @summary Get system roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomRoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getSystemRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a permission from a role
         * @summary Remove permission from role
         * @param {number} roleId ID of the role
         * @param {number} permissionId ID of the permission to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePermissionFromRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionFromRole(roleId, permissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.removePermissionFromRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing custom role
         * @summary Update a role
         * @param {number} id ID of the role to update
         * @param {CustomRoleDTO} customRoleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(id: number, customRoleDTO: CustomRoleDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(id, customRoleDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.updateRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Adds a permission to a role
         * @summary Add permission to role
         * @param {number} roleId ID of the role
         * @param {number} permissionId ID of the permission to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomRoleDTO> {
            return localVarFp.addPermissionToRole(roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new custom role
         * @summary Create a new role
         * @param {CustomRoleDTO} customRoleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(customRoleDTO: CustomRoleDTO, options?: RawAxiosRequestConfig): AxiosPromise<CustomRoleDTO> {
            return localVarFp.createRole(customRoleDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a custom role
         * @summary Delete a role
         * @param {number} id ID of the role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all roles
         * @summary Get all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options?: RawAxiosRequestConfig): AxiosPromise<Array<CustomRoleDTO>> {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all custom roles
         * @summary Get custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRoles(options?: RawAxiosRequestConfig): AxiosPromise<Array<CustomRoleDTO>> {
            return localVarFp.getCustomRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single role by ID
         * @summary Get role by ID
         * @param {number} id ID of the role to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomRoleDTO> {
            return localVarFp.getRoleById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single role by name
         * @summary Get role by name
         * @param {string} name Name of the role to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleByName(name: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomRoleDTO> {
            return localVarFp.getRoleByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns roles created by a specific user
         * @summary Get roles by creator
         * @param {number} creatorId ID of the creator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByCreator(creatorId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<CustomRoleDTO>> {
            return localVarFp.getRolesByCreator(creatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns roles that have a specific permission
         * @summary Get roles by permission
         * @param {string} permissionName Name of the permission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByPermission(permissionName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CustomRoleDTO>> {
            return localVarFp.getRolesByPermission(permissionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all system roles
         * @summary Get system roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemRoles(options?: RawAxiosRequestConfig): AxiosPromise<Array<CustomRoleDTO>> {
            return localVarFp.getSystemRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a permission from a role
         * @summary Remove permission from role
         * @param {number} roleId ID of the role
         * @param {number} permissionId ID of the permission to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomRoleDTO> {
            return localVarFp.removePermissionFromRole(roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing custom role
         * @summary Update a role
         * @param {number} id ID of the role to update
         * @param {CustomRoleDTO} customRoleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id: number, customRoleDTO: CustomRoleDTO, options?: RawAxiosRequestConfig): AxiosPromise<CustomRoleDTO> {
            return localVarFp.updateRole(id, customRoleDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Adds a permission to a role
     * @summary Add permission to role
     * @param {number} roleId ID of the role
     * @param {number} permissionId ID of the permission to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addPermissionToRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).addPermissionToRole(roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new custom role
     * @summary Create a new role
     * @param {CustomRoleDTO} customRoleDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(customRoleDTO: CustomRoleDTO, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRole(customRoleDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a custom role
     * @summary Delete a role
     * @param {number} id ID of the role to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(id: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all roles
     * @summary Get all roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getAllRoles(options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all custom roles
     * @summary Get custom roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getCustomRoles(options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getCustomRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single role by ID
     * @summary Get role by ID
     * @param {number} id ID of the role to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleById(id: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoleById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single role by name
     * @summary Get role by name
     * @param {string} name Name of the role to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleByName(name: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoleByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns roles created by a specific user
     * @summary Get roles by creator
     * @param {number} creatorId ID of the creator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRolesByCreator(creatorId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRolesByCreator(creatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns roles that have a specific permission
     * @summary Get roles by permission
     * @param {string} permissionName Name of the permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRolesByPermission(permissionName: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRolesByPermission(permissionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all system roles
     * @summary Get system roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getSystemRoles(options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getSystemRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a permission from a role
     * @summary Remove permission from role
     * @param {number} roleId ID of the role
     * @param {number} permissionId ID of the permission to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public removePermissionFromRole(roleId: number, permissionId: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).removePermissionFromRole(roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing custom role
     * @summary Update a role
     * @param {number} id ID of the role to update
     * @param {CustomRoleDTO} customRoleDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public updateRole(id: number, customRoleDTO: CustomRoleDTO, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).updateRole(id, customRoleDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SendersApi - axios parameter creator
 * @export
 */
export const SendersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new sender organization
         * @summary Create new sender
         * @param {SenderDTO} senderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSender: async (senderDTO: SenderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'senderDTO' is not null or undefined
            assertParamExists('createSender', 'senderDTO', senderDTO)
            const localVarPath = `/api/senders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(senderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a sender by ID
         * @summary Delete sender
         * @param {number} id ID of the sender to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSender: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSender', 'id', id)
            const localVarPath = `/api/senders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all document sender organizations
         * @summary Get all senders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSenders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/senders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a sender by ID
         * @summary Get sender by ID
         * @param {number} id ID of the sender to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSenderById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSenderById', 'id', id)
            const localVarPath = `/api/senders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing sender organization
         * @summary Update sender
         * @param {number} id ID of the sender to update
         * @param {SenderDTO} senderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSender: async (id: number, senderDTO: SenderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSender', 'id', id)
            // verify required parameter 'senderDTO' is not null or undefined
            assertParamExists('updateSender', 'senderDTO', senderDTO)
            const localVarPath = `/api/senders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(senderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SendersApi - functional programming interface
 * @export
 */
export const SendersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SendersApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new sender organization
         * @summary Create new sender
         * @param {SenderDTO} senderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSender(senderDTO: SenderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SenderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSender(senderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SendersApi.createSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a sender by ID
         * @summary Delete sender
         * @param {number} id ID of the sender to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSender(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSender(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SendersApi.deleteSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all document sender organizations
         * @summary Get all senders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSenders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SenderDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSenders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SendersApi.getAllSenders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a sender by ID
         * @summary Get sender by ID
         * @param {number} id ID of the sender to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSenderById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SenderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSenderById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SendersApi.getSenderById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing sender organization
         * @summary Update sender
         * @param {number} id ID of the sender to update
         * @param {SenderDTO} senderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSender(id: number, senderDTO: SenderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SenderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSender(id, senderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SendersApi.updateSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SendersApi - factory interface
 * @export
 */
export const SendersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SendersApiFp(configuration)
    return {
        /**
         * Creates a new sender organization
         * @summary Create new sender
         * @param {SenderDTO} senderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSender(senderDTO: SenderDTO, options?: RawAxiosRequestConfig): AxiosPromise<SenderDTO> {
            return localVarFp.createSender(senderDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a sender by ID
         * @summary Delete sender
         * @param {number} id ID of the sender to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSender(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSender(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all document sender organizations
         * @summary Get all senders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSenders(options?: RawAxiosRequestConfig): AxiosPromise<Array<SenderDTO>> {
            return localVarFp.getAllSenders(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a sender by ID
         * @summary Get sender by ID
         * @param {number} id ID of the sender to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSenderById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SenderDTO> {
            return localVarFp.getSenderById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing sender organization
         * @summary Update sender
         * @param {number} id ID of the sender to update
         * @param {SenderDTO} senderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSender(id: number, senderDTO: SenderDTO, options?: RawAxiosRequestConfig): AxiosPromise<SenderDTO> {
            return localVarFp.updateSender(id, senderDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SendersApi - object-oriented interface
 * @export
 * @class SendersApi
 * @extends {BaseAPI}
 */
export class SendersApi extends BaseAPI {
    /**
     * Creates a new sender organization
     * @summary Create new sender
     * @param {SenderDTO} senderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendersApi
     */
    public createSender(senderDTO: SenderDTO, options?: RawAxiosRequestConfig) {
        return SendersApiFp(this.configuration).createSender(senderDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a sender by ID
     * @summary Delete sender
     * @param {number} id ID of the sender to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendersApi
     */
    public deleteSender(id: number, options?: RawAxiosRequestConfig) {
        return SendersApiFp(this.configuration).deleteSender(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all document sender organizations
     * @summary Get all senders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendersApi
     */
    public getAllSenders(options?: RawAxiosRequestConfig) {
        return SendersApiFp(this.configuration).getAllSenders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a sender by ID
     * @summary Get sender by ID
     * @param {number} id ID of the sender to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendersApi
     */
    public getSenderById(id: number, options?: RawAxiosRequestConfig) {
        return SendersApiFp(this.configuration).getSenderById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing sender organization
     * @summary Update sender
     * @param {number} id ID of the sender to update
     * @param {SenderDTO} senderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendersApi
     */
    public updateSender(id: number, senderDTO: SenderDTO, options?: RawAxiosRequestConfig) {
        return SendersApiFp(this.configuration).updateSender(id, senderDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestApi - axios parameter creator
 * @export
 */
export const TestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A public endpoint that doesn\'t require authentication
         * @summary Public endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicEndpoint: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the current authenticated user
         * @summary Test authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestApi - functional programming interface
 * @export
 */
export const TestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestApiAxiosParamCreator(configuration)
    return {
        /**
         * A public endpoint that doesn\'t require authentication
         * @summary Public endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicEndpoint(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicEndpoint(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.publicEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the current authenticated user
         * @summary Test authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAuth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAuth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestApi.testAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestApi - factory interface
 * @export
 */
export const TestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestApiFp(configuration)
    return {
        /**
         * A public endpoint that doesn\'t require authentication
         * @summary Public endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicEndpoint(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.publicEndpoint(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the current authenticated user
         * @summary Test authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuth(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.testAuth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export class TestApi extends BaseAPI {
    /**
     * A public endpoint that doesn\'t require authentication
     * @summary Public endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public publicEndpoint(options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).publicEndpoint(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the current authenticated user
     * @summary Test authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public testAuth(options?: RawAxiosRequestConfig) {
        return TestApiFp(this.configuration).testAuth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UnifiedDocumentsApi - axios parameter creator
 * @export
 */
export const UnifiedDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a comment to any document type
         * @summary Add comment to document
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentComment: async (documentId: number, requestBody: { [key: string]: object; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('addDocumentComment', 'documentId', documentId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addDocumentComment', 'requestBody', requestBody)
            const localVarPath = `/api/documents/unified/{documentId}/comments`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns a document to a user for processing
         * @summary Assign document to user
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDocumentToUser: async (documentId: number, requestBody: { [key: string]: object; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('assignDocumentToUser', 'documentId', documentId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('assignDocumentToUser', 'requestBody', requestBody)
            const localVarPath = `/api/documents/unified/{documentId}/workflow/assign`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the workflow status of a document
         * @summary Change document workflow status
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDocumentWorkflowStatus: async (documentId: number, requestBody: { [key: string]: object; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('changeDocumentWorkflowStatus', 'documentId', documentId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('changeDocumentWorkflowStatus', 'requestBody', requestBody)
            const localVarPath = `/api/documents/unified/{documentId}/workflow/status`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a file attachment from any document type
         * @summary Delete document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentAttachment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDocumentAttachment', 'id', id)
            const localVarPath = `/api/documents/unified/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a comment from any document type
         * @summary Delete document comment
         * @param {number} commentId ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentComment: async (commentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteDocumentComment', 'commentId', commentId)
            const localVarPath = `/api/documents/unified/comments/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a file attachment for any document type
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentAttachment: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadDocumentAttachment', 'id', id)
            const localVarPath = `/api/documents/unified/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find all documents within a date range
         * @summary Find documents by date range
         * @param {string} start Start date (inclusive)
         * @param {string} end End date (inclusive)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByDateRange: async (start: string, end: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('findByDateRange', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('findByDateRange', 'end', end)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findByDateRange', 'pageable', pageable)
            const localVarPath = `/api/documents/unified/by-date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all documents in unified format
         * @summary Get all documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDocuments: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllDocuments', 'pageable', pageable)
            const localVarPath = `/api/documents/unified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single document in unified format
         * @summary Get document by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDocumentById', 'id', id)
            const localVarPath = `/api/documents/unified/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all comments for any document type
         * @summary Get document comments
         * @param {number} documentId ID of the document
         * @param {string} [type] Comment type filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentComments: async (documentId: number, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentComments', 'documentId', documentId)
            const localVarPath = `/api/documents/unified/{documentId}/comments`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get document counts by type and status
         * @summary Get document statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/documents/unified/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the workflow history of a document
         * @summary Get document workflow history
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentWorkflowHistory: async (documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentWorkflowHistory', 'documentId', documentId)
            const localVarPath = `/api/documents/unified/{documentId}/workflow/history`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current workflow status of a document
         * @summary Get document workflow status
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentWorkflowStatus: async (documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentWorkflowStatus', 'documentId', documentId)
            const localVarPath = `/api/documents/unified/{documentId}/workflow/status`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search all documents by keyword
         * @summary Search documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments: async (keyword: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('searchDocuments', 'keyword', keyword)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('searchDocuments', 'pageable', pageable)
            const localVarPath = `/api/documents/unified/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file attachment for any document type
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocumentAttachment: async (id: number, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadDocumentAttachment', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDocumentAttachment', 'file', file)
            const localVarPath = `/api/documents/unified/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads multiple file attachments for any document type
         * @summary Upload multiple document attachments
         * @param {number} id ID of the document
         * @param {Array<File>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipleAttachments: async (id: number, files: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadMultipleAttachments', 'id', id)
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadMultipleAttachments', 'files', files)
            const localVarPath = `/api/documents/unified/{id}/multiple-attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnifiedDocumentsApi - functional programming interface
 * @export
 */
export const UnifiedDocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnifiedDocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a comment to any document type
         * @summary Add comment to document
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDocumentComment(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDocumentComment(documentId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.addDocumentComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assigns a document to a user for processing
         * @summary Assign document to user
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignDocumentToUser(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignDocumentToUser(documentId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.assignDocumentToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Changes the workflow status of a document
         * @summary Change document workflow status
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeDocumentWorkflowStatus(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeDocumentWorkflowStatus(documentId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.changeDocumentWorkflowStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a file attachment from any document type
         * @summary Delete document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentAttachment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentAttachment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.deleteDocumentAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a comment from any document type
         * @summary Delete document comment
         * @param {number} commentId ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentComment(commentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentComment(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.deleteDocumentComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads a file attachment for any document type
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocumentAttachment(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocumentAttachment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.downloadDocumentAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find all documents within a date range
         * @summary Find documents by date range
         * @param {string} start Start date (inclusive)
         * @param {string} end End date (inclusive)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByDateRange(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageUnifiedDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByDateRange(start, end, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.findByDateRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all documents in unified format
         * @summary Get all documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDocuments(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageUnifiedDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDocuments(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.getAllDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single document in unified format
         * @summary Get document by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnifiedDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.getDocumentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all comments for any document type
         * @summary Get document comments
         * @param {number} documentId ID of the document
         * @param {string} [type] Comment type filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentComments(documentId: number, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentComments(documentId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.getDocumentComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get document counts by type and status
         * @summary Get document statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.getDocumentStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the workflow history of a document
         * @summary Get document workflow history
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentWorkflowHistory(documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentWorkflowHistory(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.getDocumentWorkflowHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current workflow status of a document
         * @summary Get document workflow status
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentWorkflowStatus(documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentWorkflowStatus(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.getDocumentWorkflowStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search all documents by keyword
         * @summary Search documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageUnifiedDocumentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocuments(keyword, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.searchDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file attachment for any document type
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocumentAttachment(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.uploadDocumentAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads multiple file attachments for any document type
         * @summary Upload multiple document attachments
         * @param {number} id ID of the document
         * @param {Array<File>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMultipleAttachments(id: number, files: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMultipleAttachments(id, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnifiedDocumentsApi.uploadMultipleAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UnifiedDocumentsApi - factory interface
 * @export
 */
export const UnifiedDocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnifiedDocumentsApiFp(configuration)
    return {
        /**
         * Adds a comment to any document type
         * @summary Add comment to document
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentComment(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.addDocumentComment(documentId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns a document to a user for processing
         * @summary Assign document to user
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDocumentToUser(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.assignDocumentToUser(documentId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes the workflow status of a document
         * @summary Change document workflow status
         * @param {number} documentId ID of the document
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDocumentWorkflowStatus(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.changeDocumentWorkflowStatus(documentId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a file attachment from any document type
         * @summary Delete document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentAttachment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteDocumentAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a comment from any document type
         * @summary Delete document comment
         * @param {number} commentId ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentComment(commentId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteDocumentComment(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a file attachment for any document type
         * @summary Download document attachment
         * @param {number} id ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentAttachment(id: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.downloadDocumentAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find all documents within a date range
         * @summary Find documents by date range
         * @param {string} start Start date (inclusive)
         * @param {string} end End date (inclusive)
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByDateRange(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageUnifiedDocumentDTO> {
            return localVarFp.findByDateRange(start, end, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all documents in unified format
         * @summary Get all documents
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDocuments(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageUnifiedDocumentDTO> {
            return localVarFp.getAllDocuments(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single document in unified format
         * @summary Get document by ID
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<UnifiedDocumentDTO> {
            return localVarFp.getDocumentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all comments for any document type
         * @summary Get document comments
         * @param {number} documentId ID of the document
         * @param {string} [type] Comment type filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentComments(documentId: number, type?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getDocumentComments(documentId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get document counts by type and status
         * @summary Get document statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentStats(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getDocumentStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the workflow history of a document
         * @summary Get document workflow history
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentWorkflowHistory(documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getDocumentWorkflowHistory(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current workflow status of a document
         * @summary Get document workflow status
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentWorkflowStatus(documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getDocumentWorkflowStatus(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search all documents by keyword
         * @summary Search documents
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageUnifiedDocumentDTO> {
            return localVarFp.searchDocuments(keyword, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file attachment for any document type
         * @summary Upload document attachment
         * @param {number} id ID of the document
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.uploadDocumentAttachment(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads multiple file attachments for any document type
         * @summary Upload multiple document attachments
         * @param {number} id ID of the document
         * @param {Array<File>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipleAttachments(id: number, files: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.uploadMultipleAttachments(id, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UnifiedDocumentsApi - object-oriented interface
 * @export
 * @class UnifiedDocumentsApi
 * @extends {BaseAPI}
 */
export class UnifiedDocumentsApi extends BaseAPI {
    /**
     * Adds a comment to any document type
     * @summary Add comment to document
     * @param {number} documentId ID of the document
     * @param {{ [key: string]: object; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public addDocumentComment(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).addDocumentComment(documentId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns a document to a user for processing
     * @summary Assign document to user
     * @param {number} documentId ID of the document
     * @param {{ [key: string]: object; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public assignDocumentToUser(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).assignDocumentToUser(documentId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes the workflow status of a document
     * @summary Change document workflow status
     * @param {number} documentId ID of the document
     * @param {{ [key: string]: object; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public changeDocumentWorkflowStatus(documentId: number, requestBody: { [key: string]: object; }, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).changeDocumentWorkflowStatus(documentId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a file attachment from any document type
     * @summary Delete document attachment
     * @param {number} id ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public deleteDocumentAttachment(id: number, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).deleteDocumentAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a comment from any document type
     * @summary Delete document comment
     * @param {number} commentId ID of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public deleteDocumentComment(commentId: number, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).deleteDocumentComment(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads a file attachment for any document type
     * @summary Download document attachment
     * @param {number} id ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public downloadDocumentAttachment(id: number, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).downloadDocumentAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find all documents within a date range
     * @summary Find documents by date range
     * @param {string} start Start date (inclusive)
     * @param {string} end End date (inclusive)
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public findByDateRange(start: string, end: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).findByDateRange(start, end, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all documents in unified format
     * @summary Get all documents
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public getAllDocuments(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).getAllDocuments(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single document in unified format
     * @summary Get document by ID
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public getDocumentById(id: number, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).getDocumentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all comments for any document type
     * @summary Get document comments
     * @param {number} documentId ID of the document
     * @param {string} [type] Comment type filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public getDocumentComments(documentId: number, type?: string, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).getDocumentComments(documentId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get document counts by type and status
     * @summary Get document statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public getDocumentStats(options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).getDocumentStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the workflow history of a document
     * @summary Get document workflow history
     * @param {number} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public getDocumentWorkflowHistory(documentId: number, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).getDocumentWorkflowHistory(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current workflow status of a document
     * @summary Get document workflow status
     * @param {number} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public getDocumentWorkflowStatus(documentId: number, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).getDocumentWorkflowStatus(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search all documents by keyword
     * @summary Search documents
     * @param {string} keyword Keyword to search for
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public searchDocuments(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).searchDocuments(keyword, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file attachment for any document type
     * @summary Upload document attachment
     * @param {number} id ID of the document
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public uploadDocumentAttachment(id: number, file: File, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).uploadDocumentAttachment(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads multiple file attachments for any document type
     * @summary Upload multiple document attachments
     * @param {number} id ID of the document
     * @param {Array<File>} files Files to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnifiedDocumentsApi
     */
    public uploadMultipleAttachments(id: number, files: Array<File>, options?: RawAxiosRequestConfig) {
        return UnifiedDocumentsApiFp(this.configuration).uploadMultipleAttachments(id, files, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserManagementApi - axios parameter creator
 * @export
 */
export const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a user by ID. Requires ADMIN role.
         * @summary Delete user
         * @param {number} id ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all users. Requires ADMIN role.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available user roles with their codes and display names. Useful for UI dropdowns.
         * @summary Get available user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available user statuses with their values and display names. Useful for UI dropdowns.
         * @summary Get available user statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableStatuses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single user by ID. Requires ADMIN role or to be the user requested.
         * @summary Get user by ID
         * @param {number} id ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single user by username. Requires ADMIN role or to be the user requested.
         * @summary Get user by username
         * @param {string} username Username of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByUsername', 'username', username)
            const localVarPath = `/api/users/username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a filtered list of users by role and/or status. Requires ADMIN role.
         * @summary Get users by role or status
         * @param {GetUsersByFilterRoleEnum} [role] Role to filter by. Can be either role code (ROLE_ADMIN), display name (Trưởng phòng), or enum name (DEPARTMENT_HEAD). See /api/users/roles endpoint for available roles.
         * @param {GetUsersByFilterStatusEnum} [status] Status to filter by. Can be status value (0,1,2,3), display name (Active), or enum name (ACTIVE). See /api/users/statuses endpoint for available statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByFilter: async (role?: GetUsersByFilterRoleEnum, status?: GetUsersByFilterStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a user\'s password. Requires ADMIN role or to be the user being updated.
         * @summary Update user password
         * @param {number} id ID of the user to update password
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword: async (id: number, requestBody: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePassword', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updatePassword', 'requestBody', requestBody)
            const localVarPath = `/api/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a user\'s information. Requires ADMIN role or to be the user being updated.
         * @summary Update user
         * @param {number} id ID of the user to update
         * @param {UserDTO} userDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, userDTO: UserDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'userDTO' is not null or undefined
            assertParamExists('updateUser', 'userDTO', userDTO)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementApi - functional programming interface
 * @export
 */
export const UserManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a user by ID. Requires ADMIN role.
         * @summary Delete user
         * @param {number} id ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all users. Requires ADMIN role.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all available user roles with their codes and display names. Useful for UI dropdowns.
         * @summary Get available user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getAvailableRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all available user statuses with their values and display names. Useful for UI dropdowns.
         * @summary Get available user statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableStatuses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableStatuses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getAvailableStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single user by ID. Requires ADMIN role or to be the user requested.
         * @summary Get user by ID
         * @param {number} id ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single user by username. Requires ADMIN role or to be the user requested.
         * @summary Get user by username
         * @param {string} username Username of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getUserByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a filtered list of users by role and/or status. Requires ADMIN role.
         * @summary Get users by role or status
         * @param {GetUsersByFilterRoleEnum} [role] Role to filter by. Can be either role code (ROLE_ADMIN), display name (Trưởng phòng), or enum name (DEPARTMENT_HEAD). See /api/users/roles endpoint for available roles.
         * @param {GetUsersByFilterStatusEnum} [status] Status to filter by. Can be status value (0,1,2,3), display name (Active), or enum name (ACTIVE). See /api/users/statuses endpoint for available statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByFilter(role?: GetUsersByFilterRoleEnum, status?: GetUsersByFilterStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByFilter(role, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getUsersByFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a user\'s password. Requires ADMIN role or to be the user being updated.
         * @summary Update user password
         * @param {number} id ID of the user to update password
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword(id: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(id, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a user\'s information. Requires ADMIN role or to be the user being updated.
         * @summary Update user
         * @param {number} id ID of the user to update
         * @param {UserDTO} userDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, userDTO: UserDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserManagementApi - factory interface
 * @export
 */
export const UserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementApiFp(configuration)
    return {
        /**
         * Deletes a user by ID. Requires ADMIN role.
         * @summary Delete user
         * @param {number} id ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all users. Requires ADMIN role.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDTO>> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available user roles with their codes and display names. Useful for UI dropdowns.
         * @summary Get available user roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRoles(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getAvailableRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available user statuses with their values and display names. Useful for UI dropdowns.
         * @summary Get available user statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableStatuses(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getAvailableStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single user by ID. Requires ADMIN role or to be the user requested.
         * @summary Get user by ID
         * @param {number} id ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO> {
            return localVarFp.getUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single user by username. Requires ADMIN role or to be the user requested.
         * @summary Get user by username
         * @param {string} username Username of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO> {
            return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a filtered list of users by role and/or status. Requires ADMIN role.
         * @summary Get users by role or status
         * @param {GetUsersByFilterRoleEnum} [role] Role to filter by. Can be either role code (ROLE_ADMIN), display name (Trưởng phòng), or enum name (DEPARTMENT_HEAD). See /api/users/roles endpoint for available roles.
         * @param {GetUsersByFilterStatusEnum} [status] Status to filter by. Can be status value (0,1,2,3), display name (Active), or enum name (ACTIVE). See /api/users/statuses endpoint for available statuses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByFilter(role?: GetUsersByFilterRoleEnum, status?: GetUsersByFilterStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserDTO>> {
            return localVarFp.getUsersByFilter(role, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user\'s password. Requires ADMIN role or to be the user being updated.
         * @summary Update user password
         * @param {number} id ID of the user to update password
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword(id: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updatePassword(id, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user\'s information. Requires ADMIN role or to be the user being updated.
         * @summary Update user
         * @param {number} id ID of the user to update
         * @param {UserDTO} userDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, userDTO: UserDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO> {
            return localVarFp.updateUser(id, userDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserManagementApi - object-oriented interface
 * @export
 * @class UserManagementApi
 * @extends {BaseAPI}
 */
export class UserManagementApi extends BaseAPI {
    /**
     * Deletes a user by ID. Requires ADMIN role.
     * @summary Delete user
     * @param {number} id ID of the user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public deleteUser(id: number, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all users. Requires ADMIN role.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getAllUsers(options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available user roles with their codes and display names. Useful for UI dropdowns.
     * @summary Get available user roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getAvailableRoles(options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getAvailableRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available user statuses with their values and display names. Useful for UI dropdowns.
     * @summary Get available user statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getAvailableStatuses(options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getAvailableStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single user by ID. Requires ADMIN role or to be the user requested.
     * @summary Get user by ID
     * @param {number} id ID of the user to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getUserById(id: number, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single user by username. Requires ADMIN role or to be the user requested.
     * @summary Get user by username
     * @param {string} username Username of the user to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getUserByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getUserByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a filtered list of users by role and/or status. Requires ADMIN role.
     * @summary Get users by role or status
     * @param {GetUsersByFilterRoleEnum} [role] Role to filter by. Can be either role code (ROLE_ADMIN), display name (Trưởng phòng), or enum name (DEPARTMENT_HEAD). See /api/users/roles endpoint for available roles.
     * @param {GetUsersByFilterStatusEnum} [status] Status to filter by. Can be status value (0,1,2,3), display name (Active), or enum name (ACTIVE). See /api/users/statuses endpoint for available statuses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getUsersByFilter(role?: GetUsersByFilterRoleEnum, status?: GetUsersByFilterStatusEnum, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getUsersByFilter(role, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a user\'s password. Requires ADMIN role or to be the user being updated.
     * @summary Update user password
     * @param {number} id ID of the user to update password
     * @param {{ [key: string]: string; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public updatePassword(id: number, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).updatePassword(id, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a user\'s information. Requires ADMIN role or to be the user being updated.
     * @summary Update user
     * @param {number} id ID of the user to update
     * @param {UserDTO} userDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public updateUser(id: number, userDTO: UserDTO, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).updateUser(id, userDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetUsersByFilterRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    Editor: 'EDITOR',
    DepartmentHead: 'DEPARTMENT_HEAD',
    DeputyDepartmentHead: 'DEPUTY_DEPARTMENT_HEAD',
    BureauChief: 'BUREAU_CHIEF',
    DeputyBureauChief: 'DEPUTY_BUREAU_CHIEF',
    Staff: 'STAFF',
    Secretary: 'SECRETARY',
    Clerk: 'CLERK'
} as const;
export type GetUsersByFilterRoleEnum = typeof GetUsersByFilterRoleEnum[keyof typeof GetUsersByFilterRoleEnum];
/**
 * @export
 */
export const GetUsersByFilterStatusEnum = {
    Inactive: 'INACTIVE',
    Active: 'ACTIVE',
    Blocked: 'BLOCKED',
    PendingApproval: 'PENDING_APPROVAL'
} as const;
export type GetUsersByFilterStatusEnum = typeof GetUsersByFilterStatusEnum[keyof typeof GetUsersByFilterStatusEnum];


/**
 * WorkCasesApi - axios parameter creator
 * @export
 */
export const WorkCasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a document to a work case
         * @summary Add document to work case
         * @param {number} caseId ID of the work case
         * @param {number} documentId ID of the document to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentToCase: async (caseId: number, documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('addDocumentToCase', 'caseId', caseId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('addDocumentToCase', 'documentId', documentId)
            const localVarPath = `/api/cases/{caseId}/documents/{documentId}`
                .replace(`{${"caseId"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new work case
         * @summary Create new work case
         * @param {WorkCaseDTO} workCaseDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkCase: async (workCaseDTO: WorkCaseDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workCaseDTO' is not null or undefined
            assertParamExists('createWorkCase', 'workCaseDTO', workCaseDTO)
            const localVarPath = `/api/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workCaseDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a work case by ID
         * @summary Delete work case
         * @param {number} id ID of the work case to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkCase: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkCase', 'id', id)
            const localVarPath = `/api/cases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all work cases
         * @summary Get all work cases
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkCases: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllWorkCases', 'pageable', pageable)
            const localVarPath = `/api/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns work cases past their deadline
         * @summary Get overdue cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueCases: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cases/overdue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single work case by case code
         * @summary Get work case by case code
         * @param {string} caseCode Case code of the work case to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCaseByCaseCode: async (caseCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseCode' is not null or undefined
            assertParamExists('getWorkCaseByCaseCode', 'caseCode', caseCode)
            const localVarPath = `/api/cases/code/{caseCode}`
                .replace(`{${"caseCode"}}`, encodeURIComponent(String(caseCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single work case by ID
         * @summary Get work case by ID
         * @param {number} id ID of the work case to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCaseById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkCaseById', 'id', id)
            const localVarPath = `/api/cases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns work cases assigned to a specific user
         * @summary Get work cases by assignee
         * @param {number} assigneeId ID of the assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByAssignee: async (assigneeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assigneeId' is not null or undefined
            assertParamExists('getWorkCasesByAssignee', 'assigneeId', assigneeId)
            const localVarPath = `/api/cases/assignee/{assigneeId}`
                .replace(`{${"assigneeId"}}`, encodeURIComponent(String(assigneeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns work cases created by a specific user
         * @summary Get work cases by creator
         * @param {number} creatorId ID of the creator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByCreator: async (creatorId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creatorId' is not null or undefined
            assertParamExists('getWorkCasesByCreator', 'creatorId', creatorId)
            const localVarPath = `/api/cases/creator/{creatorId}`
                .replace(`{${"creatorId"}}`, encodeURIComponent(String(creatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns work cases related to a specific document
         * @summary Get work cases by document
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByDocument: async (documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getWorkCasesByDocument', 'documentId', documentId)
            const localVarPath = `/api/cases/by-document/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns work cases with a specific priority
         * @summary Get work cases by priority
         * @param {string} priority Priority to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByPriority: async (priority: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priority' is not null or undefined
            assertParamExists('getWorkCasesByPriority', 'priority', priority)
            const localVarPath = `/api/cases/priority/{priority}`
                .replace(`{${"priority"}}`, encodeURIComponent(String(priority)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns work cases with a specific status
         * @summary Get work cases by status
         * @param {string} status Status to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByStatus: async (status: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getWorkCasesByStatus', 'status', status)
            const localVarPath = `/api/cases/status/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a document from a work case
         * @summary Remove document from work case
         * @param {number} caseId ID of the work case
         * @param {number} documentId ID of the document to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDocumentFromCase: async (caseId: number, documentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('removeDocumentFromCase', 'caseId', caseId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('removeDocumentFromCase', 'documentId', documentId)
            const localVarPath = `/api/cases/{caseId}/documents/{documentId}`
                .replace(`{${"caseId"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search work cases by keyword
         * @summary Search work cases
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkCases: async (keyword: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('searchWorkCases', 'keyword', keyword)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('searchWorkCases', 'pageable', pageable)
            const localVarPath = `/api/cases/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing work case
         * @summary Update work case
         * @param {number} id ID of the work case to update
         * @param {WorkCaseDTO} workCaseDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkCase: async (id: number, workCaseDTO: WorkCaseDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWorkCase', 'id', id)
            // verify required parameter 'workCaseDTO' is not null or undefined
            assertParamExists('updateWorkCase', 'workCaseDTO', workCaseDTO)
            const localVarPath = `/api/cases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workCaseDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkCasesApi - functional programming interface
 * @export
 */
export const WorkCasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkCasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a document to a work case
         * @summary Add document to work case
         * @param {number} caseId ID of the work case
         * @param {number} documentId ID of the document to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDocumentToCase(caseId: number, documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkCaseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDocumentToCase(caseId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.addDocumentToCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new work case
         * @summary Create new work case
         * @param {WorkCaseDTO} workCaseDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkCase(workCaseDTO: WorkCaseDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkCaseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkCase(workCaseDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.createWorkCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a work case by ID
         * @summary Delete work case
         * @param {number} id ID of the work case to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkCase(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkCase(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.deleteWorkCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all work cases
         * @summary Get all work cases
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkCases(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWorkCaseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkCases(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getAllWorkCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns work cases past their deadline
         * @summary Get overdue cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverdueCases(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkCaseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverdueCases(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getOverdueCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single work case by case code
         * @summary Get work case by case code
         * @param {string} caseCode Case code of the work case to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkCaseByCaseCode(caseCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkCaseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkCaseByCaseCode(caseCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getWorkCaseByCaseCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single work case by ID
         * @summary Get work case by ID
         * @param {number} id ID of the work case to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkCaseById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkCaseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkCaseById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getWorkCaseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns work cases assigned to a specific user
         * @summary Get work cases by assignee
         * @param {number} assigneeId ID of the assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkCasesByAssignee(assigneeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkCaseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkCasesByAssignee(assigneeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getWorkCasesByAssignee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns work cases created by a specific user
         * @summary Get work cases by creator
         * @param {number} creatorId ID of the creator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkCasesByCreator(creatorId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkCaseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkCasesByCreator(creatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getWorkCasesByCreator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns work cases related to a specific document
         * @summary Get work cases by document
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkCasesByDocument(documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkCaseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkCasesByDocument(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getWorkCasesByDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns work cases with a specific priority
         * @summary Get work cases by priority
         * @param {string} priority Priority to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkCasesByPriority(priority: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkCaseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkCasesByPriority(priority, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getWorkCasesByPriority']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns work cases with a specific status
         * @summary Get work cases by status
         * @param {string} status Status to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkCasesByStatus(status: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkCaseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkCasesByStatus(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.getWorkCasesByStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a document from a work case
         * @summary Remove document from work case
         * @param {number} caseId ID of the work case
         * @param {number} documentId ID of the document to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDocumentFromCase(caseId: number, documentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkCaseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDocumentFromCase(caseId, documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.removeDocumentFromCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search work cases by keyword
         * @summary Search work cases
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchWorkCases(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWorkCaseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchWorkCases(keyword, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.searchWorkCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing work case
         * @summary Update work case
         * @param {number} id ID of the work case to update
         * @param {WorkCaseDTO} workCaseDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkCase(id: number, workCaseDTO: WorkCaseDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkCaseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkCase(id, workCaseDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkCasesApi.updateWorkCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkCasesApi - factory interface
 * @export
 */
export const WorkCasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkCasesApiFp(configuration)
    return {
        /**
         * Adds a document to a work case
         * @summary Add document to work case
         * @param {number} caseId ID of the work case
         * @param {number} documentId ID of the document to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentToCase(caseId: number, documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<WorkCaseDTO> {
            return localVarFp.addDocumentToCase(caseId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new work case
         * @summary Create new work case
         * @param {WorkCaseDTO} workCaseDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkCase(workCaseDTO: WorkCaseDTO, options?: RawAxiosRequestConfig): AxiosPromise<WorkCaseDTO> {
            return localVarFp.createWorkCase(workCaseDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a work case by ID
         * @summary Delete work case
         * @param {number} id ID of the work case to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkCase(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkCase(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all work cases
         * @summary Get all work cases
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkCases(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageWorkCaseDTO> {
            return localVarFp.getAllWorkCases(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns work cases past their deadline
         * @summary Get overdue cases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueCases(options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkCaseDTO>> {
            return localVarFp.getOverdueCases(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single work case by case code
         * @summary Get work case by case code
         * @param {string} caseCode Case code of the work case to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCaseByCaseCode(caseCode: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkCaseDTO> {
            return localVarFp.getWorkCaseByCaseCode(caseCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single work case by ID
         * @summary Get work case by ID
         * @param {number} id ID of the work case to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCaseById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<WorkCaseDTO> {
            return localVarFp.getWorkCaseById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns work cases assigned to a specific user
         * @summary Get work cases by assignee
         * @param {number} assigneeId ID of the assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByAssignee(assigneeId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkCaseDTO>> {
            return localVarFp.getWorkCasesByAssignee(assigneeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns work cases created by a specific user
         * @summary Get work cases by creator
         * @param {number} creatorId ID of the creator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByCreator(creatorId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkCaseDTO>> {
            return localVarFp.getWorkCasesByCreator(creatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns work cases related to a specific document
         * @summary Get work cases by document
         * @param {number} documentId ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByDocument(documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkCaseDTO>> {
            return localVarFp.getWorkCasesByDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns work cases with a specific priority
         * @summary Get work cases by priority
         * @param {string} priority Priority to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByPriority(priority: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkCaseDTO>> {
            return localVarFp.getWorkCasesByPriority(priority, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns work cases with a specific status
         * @summary Get work cases by status
         * @param {string} status Status to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkCasesByStatus(status: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkCaseDTO>> {
            return localVarFp.getWorkCasesByStatus(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a document from a work case
         * @summary Remove document from work case
         * @param {number} caseId ID of the work case
         * @param {number} documentId ID of the document to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDocumentFromCase(caseId: number, documentId: number, options?: RawAxiosRequestConfig): AxiosPromise<WorkCaseDTO> {
            return localVarFp.removeDocumentFromCase(caseId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search work cases by keyword
         * @summary Search work cases
         * @param {string} keyword Keyword to search for
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkCases(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PageWorkCaseDTO> {
            return localVarFp.searchWorkCases(keyword, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing work case
         * @summary Update work case
         * @param {number} id ID of the work case to update
         * @param {WorkCaseDTO} workCaseDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkCase(id: number, workCaseDTO: WorkCaseDTO, options?: RawAxiosRequestConfig): AxiosPromise<WorkCaseDTO> {
            return localVarFp.updateWorkCase(id, workCaseDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkCasesApi - object-oriented interface
 * @export
 * @class WorkCasesApi
 * @extends {BaseAPI}
 */
export class WorkCasesApi extends BaseAPI {
    /**
     * Adds a document to a work case
     * @summary Add document to work case
     * @param {number} caseId ID of the work case
     * @param {number} documentId ID of the document to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public addDocumentToCase(caseId: number, documentId: number, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).addDocumentToCase(caseId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new work case
     * @summary Create new work case
     * @param {WorkCaseDTO} workCaseDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public createWorkCase(workCaseDTO: WorkCaseDTO, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).createWorkCase(workCaseDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a work case by ID
     * @summary Delete work case
     * @param {number} id ID of the work case to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public deleteWorkCase(id: number, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).deleteWorkCase(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all work cases
     * @summary Get all work cases
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getAllWorkCases(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getAllWorkCases(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns work cases past their deadline
     * @summary Get overdue cases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getOverdueCases(options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getOverdueCases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single work case by case code
     * @summary Get work case by case code
     * @param {string} caseCode Case code of the work case to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getWorkCaseByCaseCode(caseCode: string, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getWorkCaseByCaseCode(caseCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single work case by ID
     * @summary Get work case by ID
     * @param {number} id ID of the work case to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getWorkCaseById(id: number, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getWorkCaseById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns work cases assigned to a specific user
     * @summary Get work cases by assignee
     * @param {number} assigneeId ID of the assignee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getWorkCasesByAssignee(assigneeId: number, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getWorkCasesByAssignee(assigneeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns work cases created by a specific user
     * @summary Get work cases by creator
     * @param {number} creatorId ID of the creator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getWorkCasesByCreator(creatorId: number, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getWorkCasesByCreator(creatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns work cases related to a specific document
     * @summary Get work cases by document
     * @param {number} documentId ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getWorkCasesByDocument(documentId: number, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getWorkCasesByDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns work cases with a specific priority
     * @summary Get work cases by priority
     * @param {string} priority Priority to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getWorkCasesByPriority(priority: string, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getWorkCasesByPriority(priority, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns work cases with a specific status
     * @summary Get work cases by status
     * @param {string} status Status to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public getWorkCasesByStatus(status: string, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).getWorkCasesByStatus(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a document from a work case
     * @summary Remove document from work case
     * @param {number} caseId ID of the work case
     * @param {number} documentId ID of the document to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public removeDocumentFromCase(caseId: number, documentId: number, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).removeDocumentFromCase(caseId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search work cases by keyword
     * @summary Search work cases
     * @param {string} keyword Keyword to search for
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public searchWorkCases(keyword: string, pageable: Pageable, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).searchWorkCases(keyword, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing work case
     * @summary Update work case
     * @param {number} id ID of the work case to update
     * @param {WorkCaseDTO} workCaseDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkCasesApi
     */
    public updateWorkCase(id: number, workCaseDTO: WorkCaseDTO, options?: RawAxiosRequestConfig) {
        return WorkCasesApiFp(this.configuration).updateWorkCase(id, workCaseDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



